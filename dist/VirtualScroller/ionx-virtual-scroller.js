import { HTMLElement, forceUpdate, h, Host, proxyCustomElement } from '@stencil/core/internal/client';
import { shallowEqual as shallowEqual$1 } from 'fast-equals';

var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

function createCommonjsModule(fn, basedir, module) {
	return module = {
		path: basedir,
		exports: {},
		require: function (path, base) {
			return commonjsRequire();
		}
	}, fn(module, module.exports), module.exports;
}

function commonjsRequire () {
	throw new Error('Dynamic requires are not currently supported by @rollup/plugin-commonjs');
}

var performanceNow = createCommonjsModule(function (module) {
// Generated by CoffeeScript 1.12.2
(function() {
  var getNanoSeconds, hrtime, loadTime, moduleLoadTime, nodeLoadTime, upTime;

  if ((typeof performance !== "undefined" && performance !== null) && performance.now) {
    module.exports = function() {
      return performance.now();
    };
  } else if ((typeof process !== "undefined" && process !== null) && process.hrtime) {
    module.exports = function() {
      return (getNanoSeconds() - nodeLoadTime) / 1e6;
    };
    hrtime = process.hrtime;
    getNanoSeconds = function() {
      var hr;
      hr = hrtime();
      return hr[0] * 1e9 + hr[1];
    };
    moduleLoadTime = getNanoSeconds();
    upTime = process.uptime() * 1e9;
    nodeLoadTime = moduleLoadTime - upTime;
  } else if (Date.now) {
    module.exports = function() {
      return Date.now() - loadTime;
    };
    loadTime = Date.now();
  } else {
    module.exports = function() {
      return new Date().getTime() - loadTime;
    };
    loadTime = new Date().getTime();
  }

}).call(commonjsGlobal);

//# sourceMappingURL=performance-now.js.map
});

var root = typeof window === 'undefined' ? commonjsGlobal : window
  , vendors = ['moz', 'webkit']
  , suffix = 'AnimationFrame'
  , raf = root['request' + suffix]
  , caf = root['cancel' + suffix] || root['cancelRequest' + suffix];

for(var i = 0; !raf && i < vendors.length; i++) {
  raf = root[vendors[i] + 'Request' + suffix];
  caf = root[vendors[i] + 'Cancel' + suffix]
      || root[vendors[i] + 'CancelRequest' + suffix];
}

// Some versions of FF have rAF but not cAF
if(!raf || !caf) {
  var last = 0
    , id = 0
    , queue = []
    , frameDuration = 1000 / 60;

  raf = function(callback) {
    if(queue.length === 0) {
      var _now = performanceNow()
        , next = Math.max(0, frameDuration - (_now - last));
      last = next + _now;
      setTimeout(function() {
        var cp = queue.slice(0);
        // Clear queue here to prevent
        // callbacks from appending listeners
        // to the current frame's queue
        queue.length = 0;
        for(var i = 0; i < cp.length; i++) {
          if(!cp[i].cancelled) {
            try{
              cp[i].callback(last);
            } catch(e) {
              setTimeout(function() { throw e }, 0);
            }
          }
        }
      }, Math.round(next));
    }
    queue.push({
      handle: ++id,
      callback: callback,
      cancelled: false
    });
    return id
  };

  caf = function(handle) {
    for(var i = 0; i < queue.length; i++) {
      if(queue[i].handle === handle) {
        queue[i].cancelled = true;
      }
    }
  };
}

var raf_1 = function(fn) {
  // Wrap in a new function to prevent
  // `cancel` potentially being assigned
  // to the native rAF function
  return raf.call(root, fn)
};
var cancel = function() {
  caf.apply(root, arguments);
};
var polyfill = function(object) {
  if (!object) {
    object = root;
  }
  object.requestAnimationFrame = raf;
  object.cancelAnimationFrame = caf;
};
raf_1.cancel = cancel;
raf_1.polyfill = polyfill;

var cancelAnimationFrame = raf_1.cancel;
function setTimeout$1(callback, delay) {
  var startedAt = Date.now();
  var animationFrame = raf_1(tick);

  function tick() {
    if (Date.now() - startedAt >= delay) {
      callback();
    } else {
      animationFrame = raf_1(tick);
    }
  }

  return {
    clear: function clear() {
      return cancelAnimationFrame(animationFrame);
    }
  };
}
function clearTimeout(timeout) {
  if (timeout) {
    timeout.clear();
  }
}

/**
 * Rounds coordinates upto 4th decimal place (after dot) and appends "px".
 * Small numbers could be printed as `"1.2345e-50"` unless rounded:
 * that would be invalid "px" value in CSS.
 * @param {number}
 * @return {string}
 */
function px(number) {
  // Fractional pixels are used on "retina" screens.
  return number.toFixed(2) + 'px';
}

// A workaround for `<tbody/>` not being able to have `padding`.
var BROWSER_NOT_SUPPORTED_ERROR = 'It looks like you\'re using Internet Explorer which doesn\'t support CSS variables required for a <tbody/> container. VirtualScroller has been switched into "bypass" mode (render all items). See: https://gitlab.com/catamphetamine/virtual-scroller/-/issues/1';
function supportsTbody() {
  // Detect Internet Explorer.
  // https://stackoverflow.com/questions/19999388/check-if-user-is-using-ie
  // `documentMode` is an IE-only property.
  // Supports IE 9-11. Maybe even IE 8.
  // http://msdn.microsoft.com/en-us/library/ie/cc196988(v=vs.85).aspx
  if (typeof window !== 'undefined' && window.document.documentMode) {
    // CSS variables aren't supported in Internet Explorer.
    return false;
  }

  return true;
}
function addTbodyStyles(tbody) {
  // `classList.add` is supported in Internet Explorer 10+.
  tbody.classList.add('VirtualScroller');
  var style = document.getElementById('VirtualScrollerStyle');

  if (!style) {
    style = document.createElement('style');
    style.id = 'VirtualScrollerStyle'; // CSS variables aren't supported in Internet Explorer.

    style.innerText = "\n\t\t\ttbody.VirtualScroller:before {\n\t\t\t\tcontent: '';\n\t\t\t\tdisplay: table-row;\n\t\t\t\theight: var(--VirtualScroller-paddingTop);\n\t\t\t}\n\t\t\ttbody.VirtualScroller:after {\n\t\t\t\tcontent: '';\n\t\t\t\tdisplay: table-row;\n\t\t\t\theight: var(--VirtualScroller-paddingBottom);\n\t\t\t}\n\t\t".replace(/[\n\t]/g, '');
    document.head.appendChild(style);
  }
}
function setTbodyPadding(tbody, beforeItemsHeight, afterItemsHeight) {
  // CSS variables aren't supported in Internet Explorer.
  tbody.style.setProperty('--VirtualScroller-paddingTop', px(beforeItemsHeight));
  tbody.style.setProperty('--VirtualScroller-paddingBottom', px(afterItemsHeight));
}

function _classCallCheck$8(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties$8(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass$8(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties$8(Constructor.prototype, protoProps); if (staticProps) _defineProperties$8(Constructor, staticProps); return Constructor; }

var Screen =
/*#__PURE__*/
function () {
  function Screen() {
    _classCallCheck$8(this, Screen);
  }

  _createClass$8(Screen, [{
    key: "getChildElementTopOffset",

    /**
     * Returns a child element's "top offset", relative to the `parentElement`'s top edge.
     * @param  {Element} parentElement
     * @param  {number} childElementIndex
     * @return {number}
     */
    value: function getChildElementTopOffset(parentElement, childElementIndex) {
      return parentElement.childNodes[childElementIndex].getBoundingClientRect().top;
    }
    /**
     * Returns a child element's height.
     * @param  {Element} parentElement
     * @param  {number} childElementIndex
     * @return {number}
     */

  }, {
    key: "getChildElementHeight",
    value: function getChildElementHeight(parentElement, childElementIndex) {
      return this.getElementHeight(parentElement.childNodes[childElementIndex]);
    }
    /**
     * Returns the count of child elements of an element.
     * @param  {Element} parentElement
     * @return {number}
     */

  }, {
    key: "getChildElementsCount",
    value: function getChildElementsCount(parentElement) {
      return parentElement.childNodes.length;
    }
    /**
     * Removes all child elements of an element.
     * @param  {Element} element
     */

  }, {
    key: "clearElement",
    value: function clearElement(element) {
      while (element.firstChild) {
        element.removeChild(element.firstChild);
      }
    }
    /**
     * Returns an element's height.
     * @param  {Element} element
     * @return {number}
     */

  }, {
    key: "getElementHeight",
    value: function getElementHeight(element) {
      // `offsetHeight` is not precise enough (doesn't return fractional pixels).
      // return element.offsetHeight
      return element.getBoundingClientRect().height;
    }
  }]);

  return Screen;
}();

function _typeof$1(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof$1 = function _typeof(obj) { return typeof obj; }; } else { _typeof$1 = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof$1(obj); }

function _possibleConstructorReturn(self, call) { if (call && (_typeof$1(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _classCallCheck$7(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties$7(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass$7(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties$7(Constructor.prototype, protoProps); if (staticProps) _defineProperties$7(Constructor, staticProps); return Constructor; }

var ScrollableContainer =
/*#__PURE__*/
function () {
  /**
   * Constructs a new "scrollable container" from an element.
   * @param {Element} scrollableContainer
   */
  function ScrollableContainer(element) {
    _classCallCheck$7(this, ScrollableContainer);

    this.element = element;
  }
  /**
   * Returns the current scroll position.
   * @return {number}
   */


  _createClass$7(ScrollableContainer, [{
    key: "getScrollY",
    value: function getScrollY() {
      return this.element.scrollTop;
    }
    /**
     * Scrolls to a specific position.
     * @param {number} scrollY
     */

  }, {
    key: "scrollToY",
    value: function scrollToY(scrollY) {
      // IE 11 doesn't seem to have a `.scrollTo()` method.
      // https://gitlab.com/catamphetamine/virtual-scroller/-/issues/10
      // https://stackoverflow.com/questions/39908825/window-scrollto-is-not-working-in-internet-explorer-11
      if (this.element.scrollTo) {
        this.element.scrollTo(0, scrollY);
      } else {
        this.element.scrollTop = scrollY;
      }
    }
    /**
     * Returns "scrollable container" width,
     * i.e. the available width for its content.
     * @return {number}
     */

  }, {
    key: "getWidth",
    value: function getWidth() {
      return this.element.offsetWidth;
    }
    /**
     * Returns the height of the "scrollable container" itself.
     * Not to be confused with the height of "scrollable container"'s content.
     * @return {number}
     */

  }, {
    key: "getHeight",
    value: function getHeight() {
      // if (!this.element && !precise) {
      // 	return getScreenHeight()
      // }
      return this.element.offsetHeight;
    }
    /**
     * Returns the height of the content in a scrollable container.
     * For example, a scrollable container can have a height of 500px,
     * but the content in it could have a height of 5000px,
     * in which case a vertical scrollbar is rendered, and only
     * one-tenth of all the items are shown at any given moment.
     * This function is currently only used when using the
     * `preserveScrollPositionOfTheBottomOfTheListOnMount` feature.
     * @return {number}
     */

  }, {
    key: "getContentHeight",
    value: function getContentHeight() {
      return this.element.scrollHeight;
    }
    /**
     * Returns a "top offset" of an element
     * relative to the "scrollable container"'s top edge.
     * @param {Element} element
     * @return {number}
     */

  }, {
    key: "getTopOffset",
    value: function getTopOffset(element) {
      var scrollableContainerTop = this.element.getBoundingClientRect().top;
      var scrollableContainerBorderTopWidth = this.element.clientTop;
      var top = element.getBoundingClientRect().top;
      return top - scrollableContainerTop + this.getScrollY() - scrollableContainerBorderTopWidth;
    } // isVisible() {
    // 	const { top, bottom } = this.element.getBoundingClientRect()
    // 	return bottom > 0 && top < getScreenHeight()
    // }

    /**
     * Adds a "scroll" event listener to the "scrollable container".
     * @param {onScroll} Should be called whenever the scroll position inside the "scrollable container" (potentially) changes.
     * @return {function} Returns a function that stops listening.
     */

  }, {
    key: "addScrollListener",
    value: function addScrollListener(onScroll) {
      var _this = this;

      this.element.addEventListener('scroll', onScroll);
      return function () {
        return _this.element.removeEventListener('scroll', onScroll);
      };
    }
    /**
     * Adds a "resize" event listener to the "scrollable container".
     * @param {onResize} Should be called whenever the "scrollable container"'s width or height (potentially) changes.
     * @param  {Element} options.container — The result of the `getContainerElement()` function that was passed in `VirtualScroller` constructor. For example, DOM renderer uses it to filter-out unrelated "resize" events.
     * @return {function} Returns a function that stops listening.
     */

  }, {
    key: "onResize",
    value: function onResize(_onResize, _ref) {
      var _this2 = this;

      var container = _ref.container;
      // Could somehow track DOM Element size.
      // For now, `scrollableContainer` is supposed to have constant width and height.
      // (unless window is resized).
      // https://developer.mozilla.org/en-US/docs/Web/API/ResizeObserver
      // https://web.dev/resize-observer/
      var unobserve;

      if (typeof ResizeObserver !== 'undefined') {
        var resizeObserver = new ResizeObserver(function (entries) {
          // if (entry.contentBoxSize) {
          // 	// https://developer.mozilla.org/en-US/docs/Web/API/ResizeObserverEntry/contentBoxSize
          // 	const width = entry.contentBoxSize.inlineSize
          // 	const height = entry.contentBoxSize.blockSize
          // }

          _onResize();
        });
        resizeObserver.observe(this.element);

        unobserve = function unobserve() {
          return resizeObserver.unobserve(_this2.element);
        };
      } // I guess, if window is resized, `onResize()` will be triggered twice:
      // once for window resize, and once for the scrollable container resize.
      // But `onResize()` also has an internal check: if the container size
      // hasn't changed since the previous time `onResize()` has been called,
      // then `onResize()` doesn't do anything, so, I guess, there shouldn't be
      // any "performance implications" of running the listener twice in such case.


      var unlistenGlobalResize = addGlobalResizeListener(_onResize, {
        container: container
      });
      return function () {
        if (unobserve) {
          unobserve();
        }

        unlistenGlobalResize();
      };
    }
  }]);

  return ScrollableContainer;
}();
var ScrollableWindowContainer =
/*#__PURE__*/
function (_ScrollableContainer) {
  _inherits(ScrollableWindowContainer, _ScrollableContainer);

  function ScrollableWindowContainer() {
    _classCallCheck$7(this, ScrollableWindowContainer);

    return _possibleConstructorReturn(this, _getPrototypeOf(ScrollableWindowContainer).call(this, window));
  }
  /**
   * Returns the current scroll position.
   * @return {number}
   */


  _createClass$7(ScrollableWindowContainer, [{
    key: "getScrollY",
    value: function getScrollY() {
      // `window.scrollY` is not supported by Internet Explorer.
      return window.pageYOffset;
    }
    /**
     * Returns "scrollable container" width,
     * i.e. the available width for its content.
     * @return {number}
     */

  }, {
    key: "getWidth",
    value: function getWidth() {
      // https://javascript.info/size-and-scroll-window
      // `<!DOCTYPE html>` may be required in order for this to work correctly.
      // Includes scrollbar (if any).
      // Correctly reflects page zoom in iOS Safari.
      // (scales screen width accordingly).
      // But, includes scrollbar (if any).
      return window.innerWidth;
    }
    /**
     * Returns the height of the "scrollable container" itself.
     * Not to be confused with the height of "scrollable container"'s content.
     * @return {number}
     */

  }, {
    key: "getHeight",
    value: function getHeight() {
      // https://javascript.info/size-and-scroll-window
      // `<!DOCTYPE html>` is required in order for this to work correctly.
      // Without it, the returned height would be the height of the entire document.
      // Includes scrollbar (if any).
      // Supports iOS Safari's dynamically shown/hidden
      // top URL bar and bottom actions bar.
      // https://codesandbox.io/s/elegant-fog-iddrh
      // Tested in IE 11.
      // It also correctly reflects page zoom in iOS Safari.
      // (scales screen height accordingly).
      // But, includes scrollbar (if any).
      return window.innerHeight;
    }
    /**
     * Returns the height of the content in a scrollable container.
     * For example, a scrollable container can have a height of 500px,
     * but the content in it could have a height of 5000px,
     * in which case a vertical scrollbar is rendered, and only
     * one-tenth of all the items are shown at any given moment.
     * This function is currently only used when using the
     * `preserveScrollPositionOfTheBottomOfTheListOnMount` feature.
     * @return {number}
     */

  }, {
    key: "getContentHeight",
    value: function getContentHeight() {
      return document.documentElement.scrollHeight;
    }
    /**
     * Returns a "top offset" of an element
     * relative to the "scrollable container"'s top edge.
     * @param {Element} element
     * @return {number}
     */

  }, {
    key: "getTopOffset",
    value: function getTopOffset(element) {
      var borderTopWidth = document.clientTop || document.body.clientTop || 0;
      return element.getBoundingClientRect().top + this.getScrollY() - borderTopWidth;
    }
    /**
     * Adds a "resize" event listener to the "scrollable container".
     * @param {onScroll} Should be called whenever the "scrollable container"'s width or height (potentially) changes.
     * @param  {Element} options.container — The result of the `getContainerElement()` function that was passed in `VirtualScroller` constructor. For example, DOM renderer uses it to filter-out unrelated "resize" events.
     * @return {function} Returns a function that stops listening.
     */

  }, {
    key: "onResize",
    value: function onResize(_onResize2, _ref2) {
      var container = _ref2.container;
      return addGlobalResizeListener(_onResize2, {
        container: container
      });
    } // isVisible() {
    // 	return true
    // }

  }]);

  return ScrollableWindowContainer;
}(ScrollableContainer);
/**
 * Adds a "resize" event listener to the `window`.
 * @param {onResize} Should be called whenever the "container"'s width or height (potentially) changes.
 * @param  {Element} options.container — The "container".
 * @return {function} Returns a function that stops listening.
 */

function addGlobalResizeListener(onResize, _ref3) {
  var container = _ref3.container;

  var onResizeListener = function onResizeListener() {
    // By default, `VirtualScroller` always performs a re-layout
    // on window `resize` event. But browsers (Chrome, Firefox)
    // [trigger](https://developer.mozilla.org/en-US/docs/Web/API/Window/fullScreen#Notes)
    // window `resize` event also when a user switches into fullscreen mode:
    // for example, when a user is watching a video and double-clicks on it
    // to maximize it. And also when the user goes out of the fullscreen mode.
    // Each such fullscreen mode entering/exiting will trigger window `resize`
    // event that will it turn trigger a re-layout of `VirtualScroller`,
    // resulting in bad user experience. To prevent that, such cases are filtered out.
    // Some other workaround:
    // https://stackoverflow.com/questions/23770449/embedded-youtube-video-fullscreen-or-causing-resize
    if (document.fullscreenElement) {
      // If the fullscreened element doesn't contain the list
      // (and is not the list itself), then the layout hasn't been affected,
      // so don't perform a re-layout.
      //
      // For example, suppose there's a list of items, and some item contains a video.
      // If, upon clicking such video, it plays inline, and the user enters
      // fullscreen mode while playing such inline video, then the layout won't be
      // affected, and so such `resize` event should be ignored: when
      // `document.fullscreenElement` is in a separate "branch" relative to the
      // `container`.
      //
      // Another scenario: suppose that upon click, the video doesn't play inline,
      // but instead a "Slideshow" component is open, with the video shown at the
      // center of the screen in an overlay. If then the user enters fullscreen mode,
      // the layout wouldn't be affected too, so such `resize` event should also be
      // ignored: when `document.fullscreenElement` is inside the `container`.
      //
      if (document.fullscreenElement.contains(container)) ; else {
        // The element is either inside the `container`,
        // Or is in a separate tree.
        // So the `resize` event won't affect the `container`'s dimensions.
        return;
      }
    }

    onResize();
  };

  window.addEventListener('resize', onResizeListener);
  return function () {
    return window.removeEventListener('resize', onResizeListener);
  };
}

const DOMRenderingEngine = {
  name: 'DOM',
  createScreen: function createScreen() {
    return new Screen();
  },
  // Create `scrollableContainer`.
  // On client side, `scrollableContainer` is always created.
  // On server side, `scrollableContainer` is not created (and not used).
  createScrollableContainer: function createScrollableContainer(scrollableContainer) {
    if (scrollableContainer) {
      return new ScrollableContainer(scrollableContainer);
    } else if (typeof window !== 'undefined') {
      return new ScrollableWindowContainer();
    }
  }
};

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function log() {
  if (isDebug()) {
    var _console;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    (_console = console).log.apply(_console, _toConsumableArray(['[virtual-scroller]'].concat(args)));
  }
}
function warn() {
  var _console2;

  for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    args[_key2] = arguments[_key2];
  }

  (_console2 = console).warn.apply(_console2, _toConsumableArray(['[virtual-scroller]'].concat(args)));
}
function reportError() {
  for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
    args[_key3] = arguments[_key3];
  }

  if (typeof window !== 'undefined') {
    // In a web browser.
    // Output a debug message immediately so that it's known
    // at which point did the error occur between other debug logs.
    log.apply(this, ['ERROR'].concat(args));
    setTimeout(function () {
      // Throw an error in a timeout so that it doesn't interrupt the application's flow.
      // At the same time, by throwing a client-side error, such error could be spotted
      // in some error monitoring software like `sentry.io`, while also being visible
      // in the console.
      // The `.join(' ')` part doesn't support stringifying JSON objects,
      // but those don't seem to be used in any of the error messages.
      throw new Error(['[virtual-scroller]'].concat(args).join(' '));
    }, 0);
  } else {
    var _console3;

    // On a server.
    (_console3 = console).error.apply(_console3, _toConsumableArray(['[virtual-scroller]'].concat(args)));
  }
}
function isDebug() {
  if (typeof window !== 'undefined') {
    return window.VirtualScrollerDebug === true || window.VirtualScrollerDebug === 'debug';
  }
}

function _classCallCheck$6(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties$6(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass$6(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties$6(Constructor.prototype, protoProps); if (staticProps) _defineProperties$6(Constructor, staticProps); return Constructor; }

var Layout =
/*#__PURE__*/
function () {
  function Layout(_ref) {
    var bypass = _ref.bypass,
        estimatedItemHeight = _ref.estimatedItemHeight,
        measureItemsBatchSize = _ref.measureItemsBatchSize,
        getVerticalSpacing = _ref.getVerticalSpacing,
        getColumnsCount = _ref.getColumnsCount,
        getItemHeight = _ref.getItemHeight,
        getAverageItemHeight = _ref.getAverageItemHeight;

    _classCallCheck$6(this, Layout);

    this.bypass = bypass;
    this.estimatedItemHeight = estimatedItemHeight;
    this.measureItemsBatchSize = measureItemsBatchSize;
    this.getVerticalSpacing = getVerticalSpacing;
    this.getColumnsCount = getColumnsCount;
    this.getItemHeight = getItemHeight;
    this.getAverageItemHeight = getAverageItemHeight;
  }

  _createClass$6(Layout, [{
    key: "getInitialLayoutValues",
    value: function getInitialLayoutValues(_ref2) {
      var bypass = _ref2.bypass,
          itemsCount = _ref2.itemsCount,
          visibleAreaHeightIncludingMargins = _ref2.visibleAreaHeightIncludingMargins;
      // On server side, at initialization time, there's no "visible area height",
      // so default to `1` estimated rows count.
      var estimatedRowsCount = visibleAreaHeightIncludingMargins ? this.getEstimatedRowsCountForHeight(visibleAreaHeightIncludingMargins) : 1;
      var firstShownItemIndex;
      var lastShownItemIndex; // If there're no items then `firstShownItemIndex` stays `undefined`.

      if (itemsCount > 0) {
        firstShownItemIndex = 0;
        lastShownItemIndex = this.getLastShownItemIndex(firstShownItemIndex, itemsCount, estimatedRowsCount, bypass);
      }

      return {
        beforeItemsHeight: 0,
        afterItemsHeight: 0,
        firstShownItemIndex: firstShownItemIndex,
        lastShownItemIndex: lastShownItemIndex
      };
    }
  }, {
    key: "getLastShownItemIndex",
    value: function getLastShownItemIndex(firstShownItemIndex, itemsCount, estimatedRowsCount, bypass) {
      if (this.bypass || bypass) {
        return itemsCount - 1;
      }

      return Math.min(firstShownItemIndex + (estimatedRowsCount * this.getColumnsCount() - 1), itemsCount - 1);
    }
  }, {
    key: "getEstimatedRowsCountForHeight",
    value: function getEstimatedRowsCountForHeight(height) {
      var estimatedItemHeight = this.getEstimatedItemHeight();

      if (estimatedItemHeight) {
        return Math.ceil((height + this.getVerticalSpacing()) / (estimatedItemHeight + this.getVerticalSpacing()));
      } else {
        // If no items have been rendered yet, and no `estimatedItemHeight` option
        // has been passed, then default to `1` estimated rows count in any `height`.
        return 1;
      }
    }
    /**
     * Returns estimated list item height.
     * (depends on which items have been previously rendered and measured).
     * @return {number}
     */

  }, {
    key: "getEstimatedItemHeight",
    value: function getEstimatedItemHeight() {
      return this.getAverageItemHeight() || this.estimatedItemHeight || 0;
    }
  }, {
    key: "updateLayoutForItemsDiff",
    value: function updateLayoutForItemsDiff(layout, _ref3, _ref4) {
      var prependedItemsCount = _ref3.prependedItemsCount,
          appendedItemsCount = _ref3.appendedItemsCount;
      var itemsCount = _ref4.itemsCount;
      layout.firstShownItemIndex += prependedItemsCount;
      layout.lastShownItemIndex += prependedItemsCount;
      var columnsCount = this.getColumnsCount();

      if (prependedItemsCount % columnsCount === 0) {
        // If the layout stays the same, then simply increase
        // the top and bottom margins proportionally to the amount
        // of the items added.
        var prependedRowsCount = prependedItemsCount / columnsCount;
        var appendedRowsCount = Math.ceil(appendedItemsCount / columnsCount);
        var averageItemHeight = this.getAverageItemHeight();
        var verticalSpacing = this.getVerticalSpacing();
        layout.beforeItemsHeight += prependedRowsCount * (averageItemHeight + verticalSpacing);
        layout.afterItemsHeight += appendedRowsCount * (verticalSpacing + averageItemHeight);
      } else {
        // Rows will be rebalanced as a result of prepending the items,
        // and the row heights can change as a result, so recalculate
        // `beforeItemsHeight` and `afterItemsHeight` from scratch.
        // `this.itemHeights[]` and `firstShownItemIndex`/`lastShownItemIndex`
        // have already been updated at this point.
        layout.beforeItemsHeight = this.getBeforeItemsHeight(layout.firstShownItemIndex, layout.lastShownItemIndex);
        layout.afterItemsHeight = this.getAfterItemsHeight(layout.firstShownItemIndex, layout.lastShownItemIndex, itemsCount);
      }
    }
  }, {
    key: "_getVisibleItemIndexes",
    value: function _getVisibleItemIndexes(visibleAreaTop, visibleAreaBottom, listTopOffset, itemsCount) {
      var columnsCount = this.getColumnsCount();
      var firstShownItemIndex;
      var lastShownItemIndex;
      var previousRowsHeight = 0;
      var rowsCount = Math.ceil(itemsCount / columnsCount);
      var rowIndex = 0;

      while (rowIndex < rowsCount) {
        var hasMoreRows = itemsCount > (rowIndex + 1) * columnsCount;
        var verticalSpaceAfterCurrentRow = hasMoreRows ? this.getVerticalSpacing() : 0;
        var currentRowHeight = 0;
        var columnIndex = 0;
        var i = void 0;

        while (columnIndex < columnsCount && (i = rowIndex * columnsCount + columnIndex) < itemsCount) {
          var itemHeight = this.getItemHeight(i); // If an item that hasn't been shown (and measured) yet is encountered
          // then show such item and then retry after it has been measured.

          if (itemHeight === undefined) {
            log("Item index ".concat(i, " lies within the visible area or its \"margins\", but its height hasn't been measured yet. Mark the item as \"shown\", render the list, measure the item's height and redo the layout."));

            if (firstShownItemIndex === undefined) {
              firstShownItemIndex = rowIndex * columnsCount;
            }

            var heightLeft = visibleAreaBottom - (listTopOffset + previousRowsHeight);
            lastShownItemIndex = Math.min((rowIndex + this.getEstimatedRowsCountForHeight(heightLeft)) * columnsCount - 1, // Guard against index overflow.
            itemsCount - 1);
            return {
              firstNonMeasuredItemIndex: i,
              firstShownItemIndex: firstShownItemIndex,
              lastShownItemIndex: lastShownItemIndex
            };
          }

          currentRowHeight = Math.max(currentRowHeight, itemHeight); // If this is the first item visible
          // then start showing items from this row.

          if (firstShownItemIndex === undefined) {
            if (listTopOffset + previousRowsHeight + currentRowHeight > visibleAreaTop) {
              log('First shown row index', rowIndex);
              firstShownItemIndex = rowIndex * columnsCount;
            }
          } // If this item is the last one visible in the viewport then exit.


          if (listTopOffset + previousRowsHeight + currentRowHeight + verticalSpaceAfterCurrentRow > visibleAreaBottom) {
            log('Last shown row index', rowIndex); // The list height is estimated until all items have been seen,
            // so it's possible that even when the list DOM element happens
            // to be in the viewport in reality the list isn't visible
            // in which case `firstShownItemIndex` will be `undefined`.

            if (firstShownItemIndex !== undefined) {
              lastShownItemIndex = Math.min( // The index of the last item in the current row.
              (rowIndex + 1) * columnsCount - 1, // Guards against index overflow.
              itemsCount - 1);
            }

            return {
              firstShownItemIndex: firstShownItemIndex,
              lastShownItemIndex: lastShownItemIndex
            };
          }

          columnIndex++;
        }

        previousRowsHeight += currentRowHeight; // If there're more rows below the current row, then add vertical spacing.

        previousRowsHeight += verticalSpaceAfterCurrentRow;
        rowIndex++;
      } // If there're no more items then the last item is the last one to show.


      if (firstShownItemIndex !== undefined && lastShownItemIndex === undefined) {
        lastShownItemIndex = itemsCount - 1;
        log('Last item index (is fully visible)', lastShownItemIndex);
      }

      return {
        firstShownItemIndex: firstShownItemIndex,
        lastShownItemIndex: lastShownItemIndex
      };
    } // Finds the items which are displayed in the viewport.

  }, {
    key: "getVisibleItemIndexes",
    value: function getVisibleItemIndexes(visibleAreaTop, visibleAreaBottom, listTopOffset, itemsCount) {
      var _this$_getVisibleItem = this._getVisibleItemIndexes(visibleAreaTop, visibleAreaBottom, listTopOffset, itemsCount),
          firstNonMeasuredItemIndex = _this$_getVisibleItem.firstNonMeasuredItemIndex,
          firstShownItemIndex = _this$_getVisibleItem.firstShownItemIndex,
          lastShownItemIndex = _this$_getVisibleItem.lastShownItemIndex;

      var redoLayoutAfterMeasuringItemHeights = firstNonMeasuredItemIndex !== undefined; // If some items will be rendered in order to measure their height,
      // and it's not a `preserveScrollPositionOnPrependItems` case,
      // then limit the amount of such items being measured in a single pass.

      if (redoLayoutAfterMeasuringItemHeights && this.measureItemsBatchSize) {
        var maxAllowedLastShownItemIndex = firstNonMeasuredItemIndex + this.measureItemsBatchSize - 1;
        var columnsCount = this.getColumnsCount();
        lastShownItemIndex = Math.min( // Also guards against index overflow.
        lastShownItemIndex, // The index of the last item in the row.
        Math.ceil(maxAllowedLastShownItemIndex / columnsCount) * columnsCount - 1);
      }

      return {
        firstShownItemIndex: firstShownItemIndex,
        lastShownItemIndex: lastShownItemIndex,
        redoLayoutAfterMeasuringItemHeights: redoLayoutAfterMeasuringItemHeights
      };
    }
  }, {
    key: "getNonVisibleListShownItemIndexes",
    value: function getNonVisibleListShownItemIndexes() {
      return {
        firstShownItemIndex: 0,
        lastShownItemIndex: 0,
        redoLayoutAfterMeasuringItemHeights: this.getItemHeight(0) === undefined
      };
    }
  }, {
    key: "getItemIndexes",
    value: function getItemIndexes(visibleAreaTop, visibleAreaBottom, listTopOffset, listHeight, itemsCount) {
      var isVisible = listTopOffset + listHeight > visibleAreaTop && listTopOffset < visibleAreaBottom;

      if (!isVisible) {
        log('The entire list is off-screen. No items are visible.');
        return;
      } // Find the items which are displayed in the viewport.


      var indexes = this.getVisibleItemIndexes(visibleAreaTop, visibleAreaBottom, listTopOffset, itemsCount); // The list height is estimated until all items have been seen,
      // so it's possible that even when the list DOM element happens
      // to be in the viewport, in reality the list isn't visible
      // in which case `firstShownItemIndex` will be `undefined`.

      if (indexes.firstShownItemIndex === undefined) {
        log('The entire list is off-screen. No items are visible.');
        return;
      }

      return indexes;
    }
    /**
     * Measures "before" items height.
     * @param  {number} firstShownItemIndex — New first shown item index.
     * @param  {number} lastShownItemIndex — New last shown item index.
     * @return {number}
     */

  }, {
    key: "getBeforeItemsHeight",
    value: function getBeforeItemsHeight(firstShownItemIndex, lastShownItemIndex) {
      var columnsCount = this.getColumnsCount();
      var firstShownRowIndex = Math.floor(firstShownItemIndex / columnsCount);
      var beforeItemsHeight = 0; // Add all "before" items height.

      var rowIndex = 0;

      while (rowIndex < firstShownRowIndex) {
        var rowHeight = 0;
        var columnIndex = 0;

        while (columnIndex < columnsCount) {
          rowHeight = Math.max(rowHeight, this.getItemHeight(rowIndex * columnsCount + columnIndex) || this.getAverageItemHeight());
          columnIndex++;
        }

        beforeItemsHeight += rowHeight;
        beforeItemsHeight += this.getVerticalSpacing();
        rowIndex++;
      }

      return beforeItemsHeight;
    }
    /**
     * Measures "after" items height.
     * @param  {number} firstShownItemIndex — New first shown item index.
     * @param  {number} lastShownItemIndex — New last shown item index.
     * @param  {number} averageItemHeight — Average item height.
     * @param  {number} verticalSpacing — Item vertical spacing.
     * @param  {number} itemsCount — Items count.
     * @return {number}
     */

  }, {
    key: "getAfterItemsHeight",
    value: function getAfterItemsHeight(firstShownItemIndex, lastShownItemIndex, itemsCount) {
      var columnsCount = this.getColumnsCount();
      var rowsCount = Math.ceil(itemsCount / columnsCount);
      var lastShownRowIndex = Math.floor(lastShownItemIndex / columnsCount);
      var afterItemsHeight = 0;
      var rowIndex = lastShownRowIndex + 1;

      while (rowIndex < rowsCount) {
        var rowHeight = 0;
        var columnIndex = 0;
        var i = void 0;

        while (columnIndex < columnsCount && (i = rowIndex * columnsCount + columnIndex) < itemsCount) {
          rowHeight = Math.max(rowHeight, this.getItemHeight(i) || this.getAverageItemHeight());
          columnIndex++;
        } // Add all "after" items height.


        afterItemsHeight += this.getVerticalSpacing();
        afterItemsHeight += rowHeight;
        rowIndex++;
      }

      return afterItemsHeight;
    }
    /**
     * Finds the indexes of the currently visible items.
     * @return {object} `{ firstShownItemIndex: number, lastShownItemIndex: number, redoLayoutAfterMeasuringItemHeights: boolean }`
     */

  }, {
    key: "getShownItemIndexes",
    value: function getShownItemIndexes(_ref5) {
      var listHeight = _ref5.listHeight,
          itemsCount = _ref5.itemsCount,
          visibleAreaIncludingMargins = _ref5.visibleAreaIncludingMargins,
          listTopOffsetInsideScrollableContainer = _ref5.listTopOffsetInsideScrollableContainer;

      if (this.bypass) {
        return {
          firstShownItemIndex: 0,
          lastShownItemIndex: itemsCount - 1
        };
      } // Finds the indexes of the items that are currently visible
      // (or close to being visible) in the scrollable container.
      // For scrollable containers other than the main screen, it could also
      // check the visibility of such scrollable container itself, because it
      // might be not visible.
      // If such kind of an optimization would hypothetically be implemented,
      // then it would also require listening for "scroll" events on the screen.
      // Overall, I suppose that such "actual visibility" feature would be
      // a very minor optimization and not something I'd deal with.


      return this.getItemIndexes(visibleAreaIncludingMargins.top, visibleAreaIncludingMargins.bottom, listTopOffsetInsideScrollableContainer, listHeight, itemsCount) || this.getNonVisibleListShownItemIndexes();
    }
  }, {
    key: "showItemsFromTheStart",
    value: function showItemsFromTheStart(layout) {
      layout.firstShownItemIndex = 0;
      layout.beforeItemsHeight = 0;
    }
  }]);

  return Layout;
}();
var LAYOUT_REASON = {
  SCROLL: 'scroll',
  STOPPED_SCROLLING: 'stopped scrolling',
  MANUAL: 'manual',
  MOUNT: 'mount',
  ITEM_HEIGHT_NOT_MEASURED: 'some item height wasn\'t measured',
  RESIZE: 'resize',
  ITEM_HEIGHT_CHANGED: 'item height changed',
  ITEMS_CHANGED: 'items changed',
  TOP_OFFSET_CHANGED: 'list top offset changed'
};

function _classCallCheck$5(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties$5(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass$5(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties$5(Constructor.prototype, protoProps); if (staticProps) _defineProperties$5(Constructor, staticProps); return Constructor; }
// but if the page styles are applied after `VirtualScroller` mounts
// (for example, if styles are applied via javascript, like Webpack does)
// then the list might not render correctly and will only show the first item.
// The reason for that would be that calling `.getListTopOffsetInsideScrollableContainer()`
// on mount returns "incorrect" `top` position because the styles haven't been applied yet.
// For example, consider a page:
// <div class="page">
//   <nav class="sidebar">...</nav>
//   <main>...</main>
// </div>
// The sidebar is styled as `position: fixed`, but until
// the page styles have been applied it's gonna be a regular `<div/>`
// meaning that `<main/>` will be rendered below the sidebar
// and will appear offscreen and so it will only render the first item.
// Then, the page styles are loaded and applied and the sidebar
// is now `position: fixed` so `<main/>` is now rendered at the top of the page
// but `VirtualScroller`'s `.render()` has already been called
// and it won't re-render until the user scrolls or the window is resized.
// This type of a bug doesn't occur in production, but it can appear
// in development mode when using Webpack. The workaround `VirtualScroller`
// implements for such cases is calling `.getListTopOffsetInsideScrollableContainer()`
// on the list container DOM element periodically (every second) to check
// if the `top` coordinate has changed as a result of CSS being applied:
// if it has then it recalculates the shown item indexes.

var WaitForStylesToLoad =
/*#__PURE__*/
function () {
  function WaitForStylesToLoad(_ref) {
    var updateLayout = _ref.updateLayout,
        getListTopOffsetInsideScrollableContainer = _ref.getListTopOffsetInsideScrollableContainer;

    _classCallCheck$5(this, WaitForStylesToLoad);

    this.updateLayout = updateLayout;
    this.getListTopOffsetInsideScrollableContainer = getListTopOffsetInsideScrollableContainer;
  }

  _createClass$5(WaitForStylesToLoad, [{
    key: "onGotListTopOffset",
    value: function onGotListTopOffset(listTopOffset) {
      if (this.listTopOffsetInsideScrollableContainer === undefined) {
        // Start periodical checks of the list's top offset
        // in order to perform a re-layout in case it changes.
        // See the comments in `WaitForStylesToLoad.js` file
        // on why can the list's top offset change, and in which circumstances.
        this.start();
      }

      this.listTopOffsetInsideScrollableContainer = listTopOffset;
    }
  }, {
    key: "start",
    value: function start() {
      this.isRendered = true;
      this.watchListTopOffset();
    }
  }, {
    key: "stop",
    value: function stop() {
      this.isRendered = false;
      clearTimeout(this.watchListTopOffsetTimer);
    }
  }, {
    key: "watchListTopOffset",
    value: function watchListTopOffset() {
      var _this = this;

      var startedAt = Date.now();

      var check = function check() {
        // If `VirtualScroller` has been unmounted
        // while `setTimeout()` was waiting, then exit.
        if (!_this.isRendered) {
          return;
        } // Skip comparing `top` coordinate of the list
        // when this function is called for the first time.


        if (_this.listTopOffsetInsideScrollableContainer !== undefined) {
          // Calling `this.getListTopOffsetInsideScrollableContainer()`
          // on an element is about 0.003 milliseconds on a modern desktop CPU,
          // so I guess it's fine calling it twice a second.
          if (_this.getListTopOffsetInsideScrollableContainer() !== _this.listTopOffsetInsideScrollableContainer) {
            _this.updateLayout({
              reason: LAYOUT_REASON.TOP_OFFSET_CHANGED
            });
          }
        } // Compare `top` coordinate of the list twice a second
        // to find out if it has changed as a result of loading CSS styles.
        // The total duration of 3 seconds would be enough for any styles to load, I guess.
        // There could be other cases changing the `top` coordinate
        // of the list (like collapsing an "accordeon" panel above the list
        // without scrolling the page), but those cases should be handled
        // by manually calling `.updateLayout()` instance method on `VirtualScroller` instance.


        if (Date.now() - startedAt < WATCH_LIST_TOP_OFFSET_MAX_DURATION) {
          _this.watchListTopOffsetTimer = setTimeout$1(check, WATCH_LIST_TOP_OFFSET_INTERVAL);
        }
      }; // Run the cycle.


      check();
    }
  }]);

  return WaitForStylesToLoad;
}();
var WATCH_LIST_TOP_OFFSET_INTERVAL = 500;
var WATCH_LIST_TOP_OFFSET_MAX_DURATION = 3000;

// For some weird reason, in Chrome, `setTimeout()` would lag up to a second (or more) behind.
/**
 * Same as `lodash`'s `debounce()` for functions with no arguments.
 * @param  {function} func
 * @param  {number} interval
 * @return {function}
 */

function debounce(func, interval) {
  var timeout;
  return function () {
    var _this = this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    clearTimeout(timeout);
    timeout = setTimeout$1(function () {
      return func.apply(_this, args);
    }, interval);
  };
}

function _classCallCheck$4(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties$4(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass$4(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties$4(Constructor.prototype, protoProps); if (staticProps) _defineProperties$4(Constructor, staticProps); return Constructor; }

function _defineProperty$2(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var Resize =
/*#__PURE__*/
function () {
  function Resize(_ref) {
    var _this = this;

    var bypass = _ref.bypass,
        scrollableContainer = _ref.scrollableContainer,
        getContainerElement = _ref.getContainerElement,
        updateLayout = _ref.updateLayout,
        resetStateAndLayout = _ref.resetStateAndLayout;

    _classCallCheck$4(this, Resize);

    _defineProperty$2(this, "onResize", debounce(function () {
      // If `VirtualScroller` has been unmounted
      // while `debounce()`'s `setTimeout()` was waiting, then exit.
      if (!_this.isRendered) {
        return;
      }

      var prevScrollableContainerWidth = _this.scrollableContainerWidth;
      var prevScrollableContainerHeight = _this.scrollableContainerHeight;
      _this.scrollableContainerWidth = _this.scrollableContainer.getWidth();
      _this.scrollableContainerHeight = _this.scrollableContainer.getHeight();

      if (_this.scrollableContainerWidth === prevScrollableContainerWidth) {
        if (_this.scrollableContainerHeight === prevScrollableContainerHeight) {
          // The dimensions of the container didn't change,
          // so there's no need to re-layout anything.
          return;
        } else {
          // Scrollable container height has changed,
          // so just recalculate shown item indexes.
          // No need to perform a re-layout from scratch.
          _this.updateLayout({
            reason: LAYOUT_REASON.RESIZE
          });
        }
      } else {
        // Reset item heights, because if scrollable container's width (or height)
        // has changed, then the list width (or height) most likely also has changed,
        // and also some CSS `@media()` rules might have been added or removed.
        // So re-render the list entirely.
        _this.resetStateAndLayout();
      }
    }, SCROLLABLE_CONTAINER_RESIZE_DEBOUNCE_INTERVAL));

    this.bypass = bypass;
    this.scrollableContainer = scrollableContainer;
    this.getContainerElement = getContainerElement;
    this.updateLayout = updateLayout;
    this.resetStateAndLayout = resetStateAndLayout;
  }

  _createClass$4(Resize, [{
    key: "listen",
    value: function listen() {
      if (this.bypass) {
        return;
      }

      this.isRendered = true;
      this.scrollableContainerWidth = this.scrollableContainer.getWidth();
      this.scrollableContainerHeight = this.scrollableContainer.getHeight();
      this.scrollableContainerUnlistenResize = this.scrollableContainer.onResize(this.onResize, {
        container: this.getContainerElement()
      });
    }
  }, {
    key: "stop",
    value: function stop() {
      this.isRendered = false;

      if (this.scrollableContainerUnlistenResize) {
        this.scrollableContainerUnlistenResize();
      }
    }
    /**
     * On scrollable container resize.
     */

  }]);

  return Resize;
}();
var SCROLLABLE_CONTAINER_RESIZE_DEBOUNCE_INTERVAL = 250;

function _classCallCheck$3(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties$3(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass$3(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties$3(Constructor.prototype, protoProps); if (staticProps) _defineProperties$3(Constructor, staticProps); return Constructor; }

function _defineProperty$1(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var Scroll =
/*#__PURE__*/
function () {
  function Scroll(_ref) {
    var _this = this;

    var bypass = _ref.bypass,
        scrollableContainer = _ref.scrollableContainer,
        updateLayout = _ref.updateLayout,
        initialScrollPosition = _ref.initialScrollPosition,
        onScrollPositionChange = _ref.onScrollPositionChange,
        isImmediateLayoutScheduled = _ref.isImmediateLayoutScheduled,
        hasNonRenderedItemsAtTheTop = _ref.hasNonRenderedItemsAtTheTop,
        hasNonRenderedItemsAtTheBottom = _ref.hasNonRenderedItemsAtTheBottom,
        getLatestLayoutVisibleAreaIncludingMargins = _ref.getLatestLayoutVisibleAreaIncludingMargins,
        preserveScrollPositionOfTheBottomOfTheListOnMount = _ref.preserveScrollPositionOfTheBottomOfTheListOnMount;

    _classCallCheck$3(this, Scroll);

    _defineProperty$1(this, "updateScrollPosition", function () {
      _this.onScrollPositionChange(_this.getScrollY());
    });

    _defineProperty$1(this, "onScroll", function () {
      // Prefer not performing a re-layout while the user is scrolling (if possible).
      // If the user doesn't scroll too far and then stops for a moment,
      // then a mid-scroll re-layout could be delayed until such a brief stop:
      // presumably, this results in better (smoother) scrolling performance,
      // delaying the work to when it doesn't introduce any stutter or "jank".
      // Reset `this.onUserStopsScrollingTimer` (will be re-created below).
      _this.cancelOnUserStopsScrollingTimer(); // See whether rendering "new" previous/next items is required
      // right now, or it can wait until the user stops scrolling.


      var forceUpdate = // If the items have been rendered at least once
      _this.getLatestLayoutVisibleAreaIncludingMargins() && ( // If the user has scrolled up past the extra "margin"
      _this.getScrollY() < _this.getLatestLayoutVisibleAreaIncludingMargins().top && // and if there're any previous non-rendered items to render.
      _this.hasNonRenderedItemsAtTheTop() || // If the user has scrolled down past the extra "margin"
      _this.getScrollY() + _this.scrollableContainer.getHeight() > _this.getLatestLayoutVisibleAreaIncludingMargins().bottom && // and if there're any next non-rendered items to render.
      _this.hasNonRenderedItemsAtTheBottom());

      if (forceUpdate) {
        log('The user has scrolled far enough: force re-layout');
      } else {
        log('The user hasn\'t scrolled too much: delay re-layout');
      }

      if (!forceUpdate) {
        // If a re-layout is already scheduled at the next "frame",
        // don't schedule a "re-layout when user stops scrolling" timer.
        if (_this.isImmediateLayoutScheduled()) {
          return;
        }

        _this.onUserStopsScrollingTimer = setTimeout$1(function () {
          _this.onUserStopsScrollingTimer = undefined;

          _this.updateLayout({
            reason: LAYOUT_REASON.STOPPED_SCROLLING
          });
        }, // "scroll" events are usually dispatched every 16 milliseconds
        // for 60fps refresh rate, so waiting for 100 milliseconds feels
        // reasonable: that would be about 6 frames of inactivity period,
        // which could mean that either the user has stopped scrolling
        // (for a moment) or the browser is lagging and stuttering
        // (skipping frames due to high load).
        // If the user continues scrolling then this timeout is constantly
        // refreshed (cancelled and then re-created).
        WAIT_FOR_USER_TO_STOP_SCROLLING_TIMEOUT);
        return;
      }

      _this.updateLayout({
        reason: LAYOUT_REASON.SCROLL
      });
    });

    this.bypass = bypass;
    this.scrollableContainer = scrollableContainer;
    this.updateLayout = updateLayout;
    this.initialScrollPosition = initialScrollPosition;
    this.onScrollPositionChange = onScrollPositionChange;
    this.isImmediateLayoutScheduled = isImmediateLayoutScheduled;
    this.hasNonRenderedItemsAtTheTop = hasNonRenderedItemsAtTheTop;
    this.hasNonRenderedItemsAtTheBottom = hasNonRenderedItemsAtTheBottom;
    this.getLatestLayoutVisibleAreaIncludingMargins = getLatestLayoutVisibleAreaIncludingMargins;

    if (preserveScrollPositionOfTheBottomOfTheListOnMount) {
      if (scrollableContainer) {
        this.preserveScrollPositionOfTheBottomOfTheListOnMount = {
          scrollableContainerContentHeight: scrollableContainer.getContentHeight()
        };
      }
    }
  }

  _createClass$3(Scroll, [{
    key: "listen",
    value: function listen() {
      if (this.initialScrollPosition !== undefined) {
        this.scrollToY(this.initialScrollPosition);
      }

      if (this.onScrollPositionChange) {
        this.updateScrollPosition();
        this.removeScrollPositionListener = this.scrollableContainer.addScrollListener(this.updateScrollPosition);
      }

      if (!this.bypass) {
        this.removeScrollListener = this.scrollableContainer.addScrollListener(this.onScroll);
      }

      if (this.preserveScrollPositionOfTheBottomOfTheListOnMount) {
        this.scrollToY(this.getScrollY() + (this.scrollableContainer.getContentHeight() - this.preserveScrollPositionOfTheBottomOfTheListOnMount.scrollableContainerContentHeight));
      }
    }
  }, {
    key: "stop",
    value: function stop() {
      if (this.removeScrollPositionListener) {
        this.removeScrollPositionListener();
      }

      if (this.removeScrollListener) {
        this.removeScrollListener();
      }

      this.cancelOnUserStopsScrollingTimer();
    }
  }, {
    key: "scrollToY",
    value: function scrollToY(scrollY) {
      this.scrollableContainer.scrollToY(scrollY);
    }
  }, {
    key: "scrollByY",
    value: function scrollByY(_scrollByY) {
      this.scrollToY(this.getScrollY() + _scrollByY);
    }
  }, {
    key: "getScrollY",
    value: function getScrollY() {
      return this.scrollableContainer.getScrollY();
    }
    /**
     * Updates the current scroll Y position in state.
     */

  }, {
    key: "cancelOnUserStopsScrollingTimer",
    value: function cancelOnUserStopsScrollingTimer() {
      if (this.onUserStopsScrollingTimer) {
        clearTimeout(this.onUserStopsScrollingTimer);
        this.onUserStopsScrollingTimer = undefined;
      }
    }
  }, {
    key: "onLayout",
    value: function onLayout() {
      // Cancel a "re-layout when user stops scrolling" timer.
      this.cancelOnUserStopsScrollingTimer();
    }
  }, {
    key: "getVisibleAreaBounds",

    /**
     * Returns visible area coordinates relative to the scrollable container.
     * @return {object} `{ top: number, bottom: number }`
     */
    value: function getVisibleAreaBounds() {
      var scrollY = this.getScrollY();
      return {
        // The first pixel of the screen.
        top: scrollY,
        // The pixel after the last pixel of the screen.
        bottom: scrollY + this.scrollableContainer.getHeight()
      };
    }
  }]);

  return Scroll;
}();
var WAIT_FOR_USER_TO_STOP_SCROLLING_TIMEOUT = 100;

function _classCallCheck$2(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties$2(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass$2(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties$2(Constructor.prototype, protoProps); if (staticProps) _defineProperties$2(Constructor, staticProps); return Constructor; }

var RestoreScroll =
/*#__PURE__*/
function () {
  function RestoreScroll(_ref) {
    var screen = _ref.screen,
        getContainerElement = _ref.getContainerElement,
        scrollBy = _ref.scrollBy;

    _classCallCheck$2(this, RestoreScroll);

    this.screen = screen;
    this.getContainerElement = getContainerElement;
    this.scrollBy = scrollBy;
  }
  /**
   * `<ReactVirtualScroller/>` calls this method.
   * @param  {any[]} previousItems
   * @param  {any[]} newItems
   * @param  {number} prependedItemsCount
   */


  _createClass$2(RestoreScroll, [{
    key: "captureScroll",
    value: function captureScroll(_ref2) {
      var previousItems = _ref2.previousItems,
          newItems = _ref2.newItems,
          prependedItemsCount = _ref2.prependedItemsCount;

      // If there were no items in the list
      // then there's no point in restoring scroll position.
      if (previousItems.length === 0) {
        return;
      } // If no items were prepended then no need to restore scroll position.


      if (prependedItemsCount === 0) {
        return;
      }

      var container = this.getContainerElement();
      var firstItemTopOffset = this.screen.getChildElementTopOffset(container, 0); // The first item is supposed to be shown when the user clicks
      // "Show previous items" button. If it isn't shown though,
      // could still calculate the first item's top position using
      // the values from `itemHeights` and `verticalSpacing`.
      // But that would be a weird non-realistic scenario.
      // if (firstShownItemIndex > 0) {
      // 	let i = firstShownItemIndex - 1
      // 	while (i >= 0) {
      // 		firstItemTopOffset += itemHeights[i] + verticalSpacing
      // 		i--
      // 	}
      // }
      // If the scroll position has already been captured for restoration,
      // then don't capture it the second time.
      // Capturing scroll position could happen when using `<ReactVirtualScroller/>`
      // because it calls `.captureScroll()` inside `ReactVirtualScroller.render()`
      // which is followed by `<VirtualScroller/>`'s `.componentDidUpdate()`
      // that also calls `.captureScroll()` with the same arguments,
      // so that second call to `.captureScroll()` is ignored.
      // Calling `.captureScroll()` inside `ReactVirtualScroller.render()`
      // is done to prevent scroll Y position from jumping
      // when showing the first page of the "Previous items".
      // See the long section of comments in `ReactVirtualScroller.render()`
      // method for more info on why is `.captureScroll()` called there.

      if (this.restoreScrollAfterRenderValues && this.restoreScrollAfterRenderValues.previousItems === previousItems && this.restoreScrollAfterRenderValues.newItems === newItems) {
        return;
      }

      this.restoreScrollAfterRenderValues = {
        previousItems: previousItems,
        newItems: newItems,
        index: prependedItemsCount,
        visibleAreaTop: firstItemTopOffset
      };
    }
  }, {
    key: "getAnchorItemIndex",
    value: function getAnchorItemIndex() {
      return this.restoreScrollAfterRenderValues.index;
    }
  }, {
    key: "shouldRestoreScrollAfterRender",
    value: function shouldRestoreScrollAfterRender() {
      return this.restoreScrollAfterRenderValues !== undefined;
    }
  }, {
    key: "getScrollDifference",
    value: function getScrollDifference() {
      var _this$restoreScrollAf = this.restoreScrollAfterRenderValues,
          index = _this$restoreScrollAf.index,
          visibleAreaTop = _this$restoreScrollAf.visibleAreaTop;
      this.restoreScrollAfterRenderValues = undefined; // `firstShownItemIndex` is supposed to be `0` here.

      var newVisibleAreaTop = this.screen.getChildElementTopOffset(this.getContainerElement(), index);
      return newVisibleAreaTop - visibleAreaTop;
    }
  }]);

  return RestoreScroll;
}();

function _classCallCheck$1(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties$1(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass$1(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties$1(Constructor.prototype, protoProps); if (staticProps) _defineProperties$1(Constructor, staticProps); return Constructor; }

var ItemHeights =
/*#__PURE__*/
function () {
  function ItemHeights(screen, getContainerElement, getItemHeight, setItemHeight) {
    _classCallCheck$1(this, ItemHeights);

    this.screen = screen;
    this.getContainerElement = getContainerElement;
    this._get = getItemHeight;
    this._set = setItemHeight;
    this.reset();
  }

  _createClass$1(ItemHeights, [{
    key: "reset",
    value: function reset() {
      this.measuredItemsHeight = 0; // "First measured item index" variable was introduced
      // because it's not always `0`: when `virtualScroller.setItems()`
      // is called, some items might get prepended, in which case
      // `this.lastMeasuredItemIndex` is updated. If there was no
      // `this.firstMeasuredItemIndex`, then the average item height
      // calculated in `.getAverage()` would be incorrect in the timeframe
      // between `.setItems()` is called and those changes have been rendered.
      // And in that timeframe, `.getAverage()` is used to calculate the "layout":
      // stuff like "before/after items height" and "estimated items count on screen".

      this.firstMeasuredItemIndex = undefined;
      this.lastMeasuredItemIndex = undefined;
    }
    /**
     * Is called after `.reset()`.
     * Initializes `this.measuredItemsHeight`, `this.firstMeasuredItemIndex`
     * and `this.lastMeasuredItemIndex` instance variables from `VirtualScroller` `state`.
     * These instance variables are used when calculating "average" item height:
     * the "average" item height is simply `this.measuredItemsHeight` divided by
     * `this.lastMeasuredItemIndex` minus `this.firstMeasuredItemIndex` plus 1.
     */

  }, {
    key: "initialize",
    value: function initialize(itemHeights) {
      var i = 0;

      while (i < itemHeights.length) {
        if (itemHeights[i] === undefined) {
          if (this.firstMeasuredItemIndex !== undefined) {
            this.lastMeasuredItemIndex = i - 1;
            break;
          }
        } else {
          if (this.firstMeasuredItemIndex === undefined) {
            this.firstMeasuredItemIndex = i;
          }

          this.measuredItemsHeight += itemHeights[i];
        }

        i++;
      }
    } // Seems to be no longer used.
    // getItemHeight(i, firstShownItemIndex) {
    // 	if (this._get(i)) {
    // 		return this._get(i)
    // 	}
    // 	const itemHeight = this._measureItemHeight(i, firstShownItemIndex)
    // 	if (itemHeight) {
    // 		this._set(i, itemHeight)
    // 		return itemHeight
    // 	}
    // 	return this.getAverage()
    // }

  }, {
    key: "_measureItemHeight",
    value: function _measureItemHeight(i, firstShownItemIndex) {
      var container = this.getContainerElement();

      if (container) {
        var elementIndex = i - firstShownItemIndex;

        if (elementIndex >= 0 && elementIndex < this.screen.getChildElementsCount(container)) {
          return this.screen.getChildElementHeight(container, elementIndex);
        }
      }
    }
    /**
     * Measures item heights:
     *
     * * For the items that haven't been previously measured,
     *   measures them for the first time.
     *
     * * For the items that have been previoulsy measured,
     *   validate that their previously measured height
     *   is still equal to their current height.
     *   The unequalness may not necessarily be caused by
     *   incorrect use of `virtual-scroller`: there are
     *   also some valid use cases when such unequalness
     *   could happen (see the comments in the code).
     *
     * @param {number} firstShownItemIndex
     * @param {number} lastShownItemIndex
     * @return {number[]} The indexes of the items that have not previously been measured and have been measured now.
     */

  }, {
    key: "measureItemHeights",
    value: function measureItemHeights(firstShownItemIndex, lastShownItemIndex) {
      // If no items are rendered, don't measure anything.
      if (firstShownItemIndex === undefined) {
        return;
      } // Reset `this.measuredItemsHeight` if it's not a "continuous" measured items list:
      // if a group of items has been measured previously, and now it has rendered a completely
      // different group of items, and there's a non-measured "gap" between those two groups,
      // then reset `this.measuredItemsHeight` and "first measured"/"last measured" item indexes.
      // For example, this could happen when `.setItems()` prepends a lot of new items.


      if (this.firstMeasuredItemIndex !== undefined) {
        if (firstShownItemIndex > this.lastMeasuredItemIndex + 1 || lastShownItemIndex < this.firstMeasuredItemIndex - 1) {
          // Reset.
          log('Non-measured items gap detected. Reset first and last measured item indexes.');
          this.reset();
        }
      }

      var nonPreviouslyMeasuredItemIndexes = [];
      var previousFirstMeasuredItemIndex = this.firstMeasuredItemIndex;
      var previousLastMeasuredItemIndex = this.lastMeasuredItemIndex;
      var firstMeasuredItemIndexHasBeenUpdated = false;
      var i = firstShownItemIndex;

      while (i <= lastShownItemIndex) {
        // Don't re-measure item heights that have been measured previously.
        // The rationale is that developers are supposed to manually call
        // `.onItemHeightChange()` every time an item's height changes.
        // If developers aren't neglecting that rule, item heights won't
        // change unexpectedly.
        // // Re-measure all shown items' heights, because an item's height
        // // might have changed since it has been measured initially.
        // // For example, if an item is a long comment with a "Show more" button,
        // // then the user might have clicked that "Show more" button.
        if (this._get(i) === undefined) {
          nonPreviouslyMeasuredItemIndexes.push(i);
          log('Item', i, 'hasn\'t been previously measured');

          var height = this._measureItemHeight(i, firstShownItemIndex);

          log('Height', height);

          this._set(i, height); // Update average item height calculation variables
          // related to the previously measured items
          // that're above the items currently being shown.
          // It is known to be a "continuous" measured items list,
          // because the code at the start of this function checks that.


          if (previousFirstMeasuredItemIndex === undefined || i < previousFirstMeasuredItemIndex) {
            this.measuredItemsHeight += height; // Update first measured item index.

            if (!firstMeasuredItemIndexHasBeenUpdated) {
              // log('Set first measured item index', i)
              this.firstMeasuredItemIndex = i;
              firstMeasuredItemIndexHasBeenUpdated = true;
            }
          } // Update average item height calculation variables
          // related to the previously measured items
          // that're below the items currently being shown.
          // It is known to be a "continuous" measured items list,
          // because the code at the start of this function checks that.


          if (previousLastMeasuredItemIndex === undefined || i > previousLastMeasuredItemIndex) {
            // If `previousLastMeasuredItemIndex` is `undefined`
            // then `previousFirstMeasuredItemIndex` is also `undefined`
            // which means that the item's `height` has already been added
            // to `this.measuredItemsHeight` in the code above,
            // so this condition guards against counting the item's `height`
            // twice in `this.measuredItemsHeight`.
            if (previousLastMeasuredItemIndex !== undefined) {
              // Add newly shown item height.
              this.measuredItemsHeight += height;
            } // Update last measured item index.


            this.lastMeasuredItemIndex = i;
          }
        } else {
          // Validate the item's height right after showing it after being hidden,
          // because, if the stored item's state isn't applied properly, the item's
          // height might be incorrect when it's rendered with that state not applied,
          // and so a developer could know that there's a bug in their code.
          var previousHeight = this._get(i);

          var _height = this._measureItemHeight(i, firstShownItemIndex);

          if (previousHeight !== _height) {
            warn('Item', i, 'height was', previousHeight, 'before it was hidden, but, after showing it again, its height is', _height, '. Perhaps you forgot to persist the item\'s state by calling `onItemStateChange(i, newState)` when it changed, and that state got lost when the item element was unmounted, which resulted in a different height when the item was shown again, but with the missing state.');
          }
        }

        i++;
      } // // Update average item height.
      // this.updateAverageItemHeight()


      return nonPreviouslyMeasuredItemIndexes;
    }
    /**
     * Re-measures item height.
     * @param  {number} i — Item index.
     * @param  {number} firstShownItemIndex
     */

  }, {
    key: "remeasureItemHeight",
    value: function remeasureItemHeight(i, firstShownItemIndex) {
      var previousHeight = this._get(i);

      var height = this._measureItemHeight(i, firstShownItemIndex); // // Because this function is called from `.onItemHeightChange()`,
      // // there're no guarantees in which circumstances a developer calls it,
      // // and for which item indexes.
      // // Therefore, to guard against cases of incorrect usage,
      // // this function won't crash anything if the item isn't rendered
      // // or hasn't been previously rendered.
      // if (height !== undefined) {
      // 	reportError(`"onItemHeightChange()" has been called for item ${i}, but that item isn't rendered.`)
      // 	return
      // }
      // if (previousHeight === undefined) {
      // 	reportError(`"onItemHeightChange()" has been called for item ${i}, but that item hasn't been rendered before.`)
      // 	return
      // }


      this._set(i, height);

      this.measuredItemsHeight += height - previousHeight;
      return height;
    } // /**
    //  * "Average" item height is stored as an instance variable.
    //  * For example, for caching, so that it isn't calculated every time it's requested.
    //  * But that would be negligible performance gain, not really worth the extra code.
    //  * Another thing it's stored for as an instance variable is
    //  * keeping "previous" "average" item height, because it can be more precise
    //  * than the newly calculated "average" item height, provided it had
    //  * more "samples" (measured items). The newly calculated average item height
    //  * could get less samples in a scenario when the scroll somehow jumps
    //  * from one position to some other distant position: in that case previous
    //  * "total measured items height" is discarded and the new one is initialized.
    //  * Could such situation happen in real life? I guess, it's unlikely.
    //  * So I'm commenting out this code, but still keeping it just in case.
    //  */
    // updateAverageItemHeight() {
    // 	this.averageItemHeightSamplesCount = this.lastMeasuredItemIndex - this.firstMeasuredItemIndex + 1
    // 	this.averageItemHeight = this.measuredItemsHeight / this.averageItemHeightSamplesCount
    // }
    //
    // /**
    //  * Public API: is called by `VirtualScroller`.
    //  * @return {number}
    //  */
    // getAverage() {
    // 	// Previously measured average item height might still be
    // 	// more precise if it contains more measured items ("samples").
    // 	if (this.previousAverageItemHeight) {
    // 		if (this.previousAverageItemHeightSamplesCount > this.averageItemHeightSamplesCount) {
    // 			return this.previousAverageItemHeight
    // 		}
    // 	}
    // 	return this.averageItemHeight || 0
    // }

    /**
     * Public API: is called by `VirtualScroller`.
     * @return {number}
     */

  }, {
    key: "getAverage",
    value: function getAverage() {
      if (this.lastMeasuredItemIndex === undefined) {
        return 0;
      }

      return this.measuredItemsHeight / (this.lastMeasuredItemIndex - this.firstMeasuredItemIndex + 1);
    }
  }, {
    key: "onPrepend",
    value: function onPrepend(count) {
      if (this.firstMeasuredItemIndex !== undefined) {
        this.firstMeasuredItemIndex += count;
        this.lastMeasuredItemIndex += count;
      }
    }
  }]);

  return ItemHeights;
}();

/**
 * Checks whether it's an "incremental" items update, and returns the "diff".
 * @param  {any[]} previousItems
 * @param  {any[]} newItems
 * @return {object} [diff]
 */
function getItemsDiff(previousItems, newItems, isEqual) {
  var firstPreviousItemIndex = -1;
  var lastPreviousItemIndex = -1;

  if (previousItems.length > 0) {
    firstPreviousItemIndex = findInArray(newItems, previousItems[0], isEqual);

    if (firstPreviousItemIndex >= 0) {
      if (arePreviousItemsPreserved(previousItems, newItems, firstPreviousItemIndex, isEqual)) {
        lastPreviousItemIndex = firstPreviousItemIndex + previousItems.length - 1;
      }
    }
  }

  var isIncrementalUpdate = firstPreviousItemIndex >= 0 && lastPreviousItemIndex >= 0;

  if (isIncrementalUpdate) {
    return {
      prependedItemsCount: firstPreviousItemIndex,
      appendedItemsCount: newItems.length - (lastPreviousItemIndex + 1)
    };
  }
}

function arePreviousItemsPreserved(previousItems, newItems, offset, isEqual) {
  // Check each item of the `previousItems` to determine
  // whether it's an "incremental" items update.
  // (an update when items are prepended or appended)
  var i = 0;

  while (i < previousItems.length) {
    if (newItems.length <= offset + i || !isEqual(newItems[offset + i], previousItems[i])) {
      return false;
    }

    i++;
  }

  return true;
}

function findInArray(array, element, isEqual) {
  var i = 0;

  while (i < array.length) {
    if (isEqual(array[i], element)) {
      return i;
    }

    i++;
  }

  return -1;
}

function getVerticalSpacing(_ref) {
  var container = _ref.container,
      screen = _ref.screen;

  if (screen.getChildElementsCount(container) > 1) {
    var firstShownRowTopOffset = screen.getChildElementTopOffset(container, 0);
    var firstShownRowHeight = screen.getChildElementHeight(container, 0);
    var i = 1;

    while (i < screen.getChildElementsCount(container)) {
      var itemTopOffset = screen.getChildElementTopOffset(container, i);
      var itemHeight = screen.getChildElementHeight(container, i); // If next row is detected.

      if (itemTopOffset !== firstShownRowTopOffset) {
        // Measure inter-row spacing.
        return itemTopOffset - (firstShownRowTopOffset + firstShownRowHeight);
      } // A row height is the maximum of its item heights.


      firstShownRowHeight = Math.max(firstShownRowHeight, itemHeight);
      i++;
    }
  }
}

// https://github.com/lodash/lodash/issues/2340

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var hasOwnProperty = Object.prototype.hasOwnProperty;
/**
 * inlined Object.is polyfill to avoid requiring consumers ship their own
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
 */

function is(x, y) {
  // SameValue algorithm
  if (x === y) {
    // Steps 1-5, 7-10
    // Steps 6.b-6.e: +0 != -0
    // Added the nonzero y check to make Flow happy, but it is redundant
    return x !== 0 || y !== 0 || 1 / x === 1 / y;
  } else {
    // Step 6.a: NaN == NaN
    return x !== x && y !== y;
  }
}
/**
 * Performs equality by iterating through keys on an object and returning false
 * when any key has values which are not strictly equal between the arguments.
 * Returns true when the values of all keys are strictly equal.
 */


function shallowEqual(objA, objB) {
  if (is(objA, objB)) {
    return true;
  }

  if (_typeof(objA) !== 'object' || objA === null || _typeof(objB) !== 'object' || objB === null) {
    return false;
  }

  var keysA = Object.keys(objA);
  var keysB = Object.keys(objB);

  if (keysA.length !== keysB.length) {
    return false;
  } // Test for A's keys different from B.


  for (var i = 0; i < keysA.length; i++) {
    if (!hasOwnProperty.call(objB, keysA[i]) || !is(objA[keysA[i]], objB[keysA[i]])) {
      return false;
    }
  }

  return true;
}

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var VirtualScroller =
/*#__PURE__*/
function () {
  /**
   * @param  {function} getContainerElement — Returns the container DOM `Element`.
   * @param  {any[]} items — The list of items.
   * @param  {Object} [options] — See README.md.
   * @return {VirtualScroller}
   */
  function VirtualScroller(getContainerElement, items) {
    var _this = this;

    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

    _classCallCheck(this, VirtualScroller);

    _defineProperty(this, "getListTopOffsetInsideScrollableContainer", function () {
      var listTopOffset = _this.scrollableContainer.getTopOffset(_this.getContainerElement());

      _this.waitForStylesToLoad.onGotListTopOffset(listTopOffset);

      return listTopOffset;
    });

    _defineProperty(this, "willUpdateState", function (newState, prevState) {
      // Ignore setting initial state.
      if (!prevState) {
        return;
      } // This function isn't currently used.
      // Was previously used to capture scroll position in order to
      // restore it later after the new state is rendered.

    });

    _defineProperty(this, "didUpdateState", function (prevState) {
      var newState = _this.getState();

      if (_this.onStateChange) {
        if (!shallowEqual(newState, prevState)) {
          _this.onStateChange(newState, prevState);
        }
      } // Ignore setting initial state.


      if (!prevState) {
        return;
      }

      if (!_this.isRendered) {
        return;
      }

      log('~ Rendered ~');
      _this.newItemsPending = undefined;
      _this.layoutResetPending = undefined;
      var redoLayoutReason = _this.redoLayoutReason;
      _this.redoLayoutReason = undefined;
      var previousItems = prevState.items;
      var newItems = newState.items;

      if (newItems !== previousItems) {
        var layoutNeedsReCalculating = true;

        var itemsDiff = _this.getItemsDiff(previousItems, newItems); // If it's an "incremental" update.


        if (itemsDiff) {
          var prependedItemsCount = itemsDiff.prependedItemsCount;

          if (prependedItemsCount > 0) {
            // The call to `.onPrepend()` must precede
            // the call to `.measureItemHeights()`
            // which is called in `.onRendered()`.
            _this.itemHeights.onPrepend(prependedItemsCount);

            if (_this.restoreScroll.shouldRestoreScrollAfterRender()) {
              layoutNeedsReCalculating = false;
              log('~ Restore Scroll Position ~');

              var scrollByY = _this.restoreScroll.getScrollDifference();

              if (scrollByY) {
                log('Scroll down by', scrollByY);

                _this.scroll.scrollByY(scrollByY);
              } else {
                log('Scroll position hasn\'t changed');
              }
            }
          }
        } else {
          _this.itemHeights.reset();

          _this.itemHeights.initialize(_this.getState().itemHeights);
        }

        if (layoutNeedsReCalculating) {
          redoLayoutReason = LAYOUT_REASON.ITEMS_CHANGED;
        }
      } // Call `.onRendered()` if shown items configuration changed.


      if (newState.firstShownItemIndex !== prevState.firstShownItemIndex || newState.lastShownItemIndex !== prevState.lastShownItemIndex || newState.items !== prevState.items) {
        _this.onRenderedNewLayout();
      }

      if (redoLayoutReason) {
        return _this.redoLayoutRightAfterRender({
          reason: redoLayoutReason
        });
      }
    });

    _defineProperty(this, "updateShownItemIndexes", function () {
      log('~ Layout results ' + (_this.bypass ? '(bypass) ' : '') + '~');

      var visibleAreaIncludingMargins = _this.getVisibleAreaBoundsIncludingMargins();

      _this.latestLayoutVisibleAreaIncludingMargins = visibleAreaIncludingMargins;

      var listTopOffsetInsideScrollableContainer = _this.getListTopOffsetInsideScrollableContainer(); // Get shown item indexes.


      var _this$layout$getShown = _this.layout.getShownItemIndexes({
        listHeight: _this.screen.getElementHeight(_this.getContainerElement()),
        itemsCount: _this.getItemsCount(),
        visibleAreaIncludingMargins: visibleAreaIncludingMargins,
        listTopOffsetInsideScrollableContainer: listTopOffsetInsideScrollableContainer
      }),
          firstShownItemIndex = _this$layout$getShown.firstShownItemIndex,
          lastShownItemIndex = _this$layout$getShown.lastShownItemIndex,
          redoLayoutAfterMeasuringItemHeights = _this$layout$getShown.redoLayoutAfterMeasuringItemHeights; // If scroll position is scheduled to be restored after render,
      // then the "anchor" item must be rendered, and all of the prepended
      // items before it, all in a single pass. This way, all of the
      // prepended items' heights could be measured right after the render
      // has finished, and the scroll position can then be immediately restored.


      if (_this.restoreScroll.shouldRestoreScrollAfterRender()) {
        if (lastShownItemIndex < _this.restoreScroll.getAnchorItemIndex()) {
          lastShownItemIndex = _this.restoreScroll.getAnchorItemIndex();
        } // `firstShownItemIndex` is always `0` when prepending items.
        // And `lastShownItemIndex` always covers all prepended items in this case.
        // None of the prepended items have been rendered before,
        // so their heights are unknown. The code at the start of this function
        // did therefore set `redoLayoutAfterMeasuringItemHeights` to `true`
        // in order to render just the first prepended item in order to
        // measure it, and only then make a decision on how many other
        // prepended items to render. But since we've instructed the code
        // to show all of the prepended items at once, there's no need to
        // "redo layout after render". Additionally, if layout was re-done
        // after render, then there would be a short interval of visual
        // "jitter" due to the scroll position not being restored because it'd
        // wait for the second layout to finish instead of being restored
        // right after the first one.


        redoLayoutAfterMeasuringItemHeights = false;
      } // Validate the heights of items to be hidden on next render.
      // For example, a user could click a "Show more" button,
      // or an "Expand YouTube video" button, which would result
      // in the actual height of the list item being different
      // from what has been initially measured in `this.itemHeights[i]`,
      // if the developer didn't call `.onItemStateChange()` and `.onItemHeightChange(i)`.


      if (!_this.validateWillBeHiddenItemHeightsAreAccurate(firstShownItemIndex, lastShownItemIndex)) {
        // Redo layout, now with the correct item heights.
        log('~ Some of the will-be-hidden item heights have changed since they\'ve last been measured. Redo layout. ~');
        return _this.updateShownItemIndexes();
      } // Measure "before" items height.


      var beforeItemsHeight = _this.layout.getBeforeItemsHeight(firstShownItemIndex, lastShownItemIndex); // Measure "after" items height.


      var afterItemsHeight = _this.layout.getAfterItemsHeight(firstShownItemIndex, lastShownItemIndex, _this.getItemsCount()); // Debugging.


      if (_this._getColumnsCount) {
        log('Columns count', _this.getColumnsCount());
      }

      log('First shown item index', firstShownItemIndex);
      log('Last shown item index', lastShownItemIndex);
      log('Before items height', beforeItemsHeight);
      log('After items height (actual or estimated)', afterItemsHeight);
      log('Average item height (calculated on previous render)', _this.itemHeights.getAverage());

      if (isDebug()) {
        log('Item heights', _this.getState().itemHeights.slice());
        log('Item states', _this.getState().itemStates.slice());
      }

      if (redoLayoutAfterMeasuringItemHeights) {
        // `this.redoLayoutReason` will be detected in `didUpdateState()`.
        // `didUpdateState()` is triggered by `this.setState()` below.
        _this.redoLayoutReason = LAYOUT_REASON.ITEM_HEIGHT_NOT_MEASURED;
      } // Optionally preload items to be rendered.


      _this.onBeforeShowItems(_this.getState().items, _this.getState().itemHeights, firstShownItemIndex, lastShownItemIndex); // Render.


      _this.setState({
        firstShownItemIndex: firstShownItemIndex,
        lastShownItemIndex: lastShownItemIndex,
        beforeItemsHeight: beforeItemsHeight,
        afterItemsHeight: afterItemsHeight // // Average item height is stored in state to differentiate between
        // // the initial state and "anything has been measured already" state.
        // averageItemHeight: this.itemHeights.getAverage()

      });
    });

    _defineProperty(this, "onUpdateShownItemIndexes", function (_ref) {
      var reason = _ref.reason;

      // If there're no items then there's no need to re-layout anything.
      if (_this.getItemsCount() === 0) {
        return;
      } // Cancel a "re-layout when user stops scrolling" timer.


      _this.scroll.onLayout(); // Cancel a re-layout that is scheduled to run at the next "frame",
      // because a re-layout will be performed right now.


      if (_this.layoutTimer) {
        clearTimeout(_this.layoutTimer);
        _this.layoutTimer = undefined;
      } // Perform a re-layout.


      log("~ Calculate Layout (on ".concat(reason, ") ~"));

      _this.updateShownItemIndexes();
    });

    _defineProperty(this, "updateLayout", function () {
      return _this.onUpdateShownItemIndexes({
        reason: LAYOUT_REASON.MANUAL
      });
    });

    _defineProperty(this, "layout", function () {
      return _this.updateLayout();
    });

    var getState = options.getState,
        setState = options.setState,
        onStateChange = options.onStateChange,
        customState = options.customState,
        preserveScrollPositionAtBottomOnMount = options.preserveScrollPositionAtBottomOnMount,
        preserveScrollPositionOfTheBottomOfTheListOnMount = options.preserveScrollPositionOfTheBottomOfTheListOnMount,
        initialScrollPosition = options.initialScrollPosition,
        onScrollPositionChange = options.onScrollPositionChange,
        measureItemsBatchSize = options.measureItemsBatchSize,
        getScrollableContainer = options.getScrollableContainer,
        getColumnsCount = options.getColumnsCount,
        getItemId = options.getItemId,
        tbody = options.tbody,
        _useTimeoutInRenderLoop = options._useTimeoutInRenderLoop;
    var bypass = options.bypass,
        estimatedItemHeight = options.estimatedItemHeight,
        onItemInitialRender = options.onItemInitialRender,
        onItemFirstRender = options.onItemFirstRender,
        scrollableContainer = options.scrollableContainer,
        state = options.state,
        renderingEngine = options.renderingEngine;
    log('~ Initialize ~'); // If `state` is passed then use `items` from `state`
    // instead of the `items` argument.

    if (state) {
      items = state.items;
    } // `getScrollableContainer` option is deprecated.
    // Use `scrollableContainer` instead.


    if (!scrollableContainer && getScrollableContainer) {
      scrollableContainer = getScrollableContainer();
    } // Could support non-DOM rendering engines.
    // For example, React Native, `<canvas/>`, etc.


    if (!renderingEngine) {
      renderingEngine = DOMRenderingEngine;
    }

    this.screen = renderingEngine.createScreen();
    this.scrollableContainer = renderingEngine.createScrollableContainer(scrollableContainer); // if (margin === undefined) {
    // 	// Renders items which are outside of the screen by this "margin".
    // 	// Is the screen height by default: seems to be the optimal value
    // 	// for "Page Up" / "Page Down" navigation and optimized mouse wheel scrolling.
    // 	margin = this.scrollableContainer ? this.scrollableContainer.getHeight() : 0
    // }
    // Work around `<tbody/>` not being able to have `padding`.
    // https://gitlab.com/catamphetamine/virtual-scroller/-/issues/1

    if (tbody) {
      if (renderingEngine.name !== 'DOM') {
        throw new Error('`tbody` option is only supported for DOM rendering engine');
      }

      log('~ <tbody/> detected ~');
      this.tbody = true;

      if (!supportsTbody()) {
        log('~ <tbody/> not supported ~');
        reportError(BROWSER_NOT_SUPPORTED_ERROR);
        bypass = true;
      }
    }

    if (bypass) {
      log('~ "bypass" mode ~');
    } // In `bypass` mode, `VirtualScroller` doesn't wait
    // for the user to scroll down to render all items:
    // instead, it renders all items right away, as if
    // the list is rendered without using `VirtualScroller`.
    // It was added just to measure how much is the
    // performance difference between using a `VirtualScroller`
    // and not using a `VirtualScroller`.
    // It turned out that unmounting large React component trees
    // is a very long process, so `VirtualScroller` does seem to
    // make sense when used in a React application.


    this.bypass = bypass; // this.bypassBatchSize = bypassBatchSize || 10
    // Using `setTimeout()` in render loop is a workaround
    // for avoiding a React error message:
    // "Maximum update depth exceeded.
    //  This can happen when a component repeatedly calls
    //  `.setState()` inside `componentWillUpdate()` or `componentDidUpdate()`.
    //  React limits the number of nested updates to prevent infinite loops."

    this._useTimeoutInRenderLoop = _useTimeoutInRenderLoop;

    if (getItemId) {
      this.isItemEqual = function (a, b) {
        return getItemId(a) === getItemId(b);
      };
    } else {
      this.isItemEqual = function (a, b) {
        return a === b;
      };
    }

    this.initialItems = items; // this.margin = margin

    this.onStateChange = onStateChange;
    this._getColumnsCount = getColumnsCount;

    if (onItemInitialRender) {
      this.onItemInitialRender = onItemInitialRender;
    } // `onItemFirstRender(i)` is deprecated, use `onItemInitialRender(item)` instead.
    else if (onItemFirstRender) {
        this.onItemInitialRender = function (item) {
          warn('`onItemFirstRender(i)` is deprecated, use `onItemInitialRender(item)` instead.');

          var _this$getState = _this.getState(),
              items = _this$getState.items;

          var i = items.indexOf(item); // The `item` could also be non-found due to the inconsistency bug:
          // The reason is that `i` can be non-consistent with the `items`
          // passed to `<VirtualScroller/>` in React due to `setState()` not being
          // instanteneous: when new `items` are passed to `<VirtualScroller/>`,
          // `VirtualScroller.setState({ items })` is called, and if `onItemFirstRender(i)`
          // is called after the aforementioned `setState()` is called but before it finishes,
          // `i` would point to an index in "previous" `items` while the application
          // would assume that `i` points to an index in the "new" `items`,
          // resulting in an incorrect item being assumed by the application
          // or even in an "array index out of bounds" error.

          if (i >= 0) {
            onItemFirstRender(i);
          }
        };
      }

    log('Items count', items.length);

    if (estimatedItemHeight) {
      log('Estimated item height', estimatedItemHeight);
    }

    if (setState) {
      this.getState = getState;

      this.setState = function (state) {
        log('Set state', state);
        setState(state, {
          willUpdateState: _this.willUpdateState,
          didUpdateState: _this.didUpdateState
        });
      };
    } else {
      this.getState = function () {
        return _this.state;
      };

      this.setState = function (state) {
        log('Set state', state);

        var prevState = _this.getState(); // Because this variant of `.setState()` is "synchronous" (immediate),
        // it can be written like `...prevState`, and no state updates would be lost.
        // But if it was "asynchronous" (not immediate), then `...prevState`
        // wouldn't work in all cases, because it could be stale in cases
        // when more than a single `setState()` call is made before
        // the state actually updates, making `prevState` stale.


        var newState = _objectSpread({}, prevState, state);

        _this.willUpdateState(newState, prevState);

        _this.state = newState;

        _this.didUpdateState(prevState);
      };
    }

    if (state) {
      log('Initial state (passed)', state);
    } // Sometimes, when `new VirtualScroller()` instance is created,
    // `getContainerElement()` might not be ready to return the "container" DOM Element yet
    // (for example, because it's not rendered yet). That's the reason why it's a getter function.
    // For example, in React `<VirtualScroller/>` component, a `VirtualScroller`
    // instance is created in the React component's `constructor()`, and at that time
    // the container Element is not yet available. The container Element is available
    // in `componentDidMount()`, but `componentDidMount()` is not executed on server,
    // which would mean that React `<VirtualScroller/>` wouldn't render at all
    // on server side, while with the `getContainerElement()` approach, on server side,
    // it still "renders" a list with a predefined amount of items in it by default.
    // (`initiallyRenderedItemsCount`, or `1`).


    this.getContainerElement = getContainerElement; // Remove any accidental text nodes from container (like whitespace).
    // Also guards against cases when someone accidentally tries
    // using `VirtualScroller` on a non-empty element.

    if (getContainerElement()) {
      this.screen.clearElement(getContainerElement());
    }

    this.itemHeights = new ItemHeights(this.screen, this.getContainerElement, function (i) {
      return _this.getState().itemHeights[i];
    }, function (i, height) {
      return _this.getState().itemHeights[i] = height;
    }); // Initialize `ItemHeights` from the initially passed `state`.

    if (state) {
      this.itemHeights.initialize(state.itemHeights);
    }

    this.layout = new Layout({
      bypass: bypass,
      estimatedItemHeight: estimatedItemHeight,
      measureItemsBatchSize: measureItemsBatchSize === undefined ? 50 : measureItemsBatchSize,
      getVerticalSpacing: function getVerticalSpacing() {
        return _this.getVerticalSpacing();
      },
      getColumnsCount: function getColumnsCount() {
        return _this.getColumnsCount();
      },
      getItemHeight: function getItemHeight(i) {
        return _this.getState().itemHeights[i];
      },
      getAverageItemHeight: function getAverageItemHeight() {
        return _this.itemHeights.getAverage();
      }
    });
    this.resize = new Resize({
      bypass: bypass,
      scrollableContainer: this.scrollableContainer,
      getContainerElement: this.getContainerElement,
      updateLayout: function updateLayout(_ref2) {
        var reason = _ref2.reason;
        return _this.onUpdateShownItemIndexes({
          reason: reason
        });
      },
      resetStateAndLayout: function resetStateAndLayout() {
        // Reset item heights, because if scrollable container's width (or height)
        // has changed, then the list width (or height) most likely also has changed,
        // and also some CSS `@media()` rules might have been added or removed.
        // So re-render the list entirely.
        log('~ Scrollable container size changed, re-measure item heights. ~');
        _this.redoLayoutReason = LAYOUT_REASON.RESIZE; // `this.layoutResetPending` flag will be cleared in `didUpdateState()`.

        _this.layoutResetPending = true;
        log('Reset state'); // Calling `this.setState(state)` will trigger `didUpdateState()`.
        // `didUpdateState()` will detect `this.redoLayoutReason`.

        _this.setState(_this.getInitialLayoutState(_this.newItemsPending || _this.getState().items));
      }
    });

    if (preserveScrollPositionAtBottomOnMount) {
      warn('`preserveScrollPositionAtBottomOnMount` option/property has been renamed to `preserveScrollPositionOfTheBottomOfTheListOnMount`');
    }

    this.preserveScrollPositionOfTheBottomOfTheListOnMount = preserveScrollPositionOfTheBottomOfTheListOnMount || preserveScrollPositionAtBottomOnMount;
    this.scroll = new Scroll({
      bypass: this.bypass,
      scrollableContainer: this.scrollableContainer,
      updateLayout: function updateLayout(_ref3) {
        var reason = _ref3.reason;
        return _this.onUpdateShownItemIndexes({
          reason: reason
        });
      },
      initialScrollPosition: initialScrollPosition,
      onScrollPositionChange: onScrollPositionChange,
      isImmediateLayoutScheduled: function isImmediateLayoutScheduled() {
        return _this.layoutTimer;
      },
      hasNonRenderedItemsAtTheTop: function hasNonRenderedItemsAtTheTop() {
        return _this.getState().firstShownItemIndex > 0;
      },
      hasNonRenderedItemsAtTheBottom: function hasNonRenderedItemsAtTheBottom() {
        return _this.getState().lastShownItemIndex < _this.getItemsCount() - 1;
      },
      getLatestLayoutVisibleAreaIncludingMargins: function getLatestLayoutVisibleAreaIncludingMargins() {
        return _this.latestLayoutVisibleAreaIncludingMargins;
      },
      preserveScrollPositionOfTheBottomOfTheListOnMount: this.preserveScrollPositionOfTheBottomOfTheListOnMount
    });
    this.restoreScroll = new RestoreScroll({
      screen: this.screen,
      getContainerElement: this.getContainerElement
    });
    this.waitForStylesToLoad = new WaitForStylesToLoad({
      updateLayout: function updateLayout(_ref4) {
        var reason = _ref4.reason;
        return _this.onUpdateShownItemIndexes({
          reason: reason
        });
      },
      getListTopOffsetInsideScrollableContainer: this.getListTopOffsetInsideScrollableContainer
    });
    this.setState(state || this.getInitialState(customState));
  }
  /**
   * Returns the initial state of the `VirtualScroller`.
   * @param  {object} [customState] — Any additional "custom" state may be stored in `VirtualScroller`'s state. For example, React implementation stores item "refs" as "custom" state.
   * @return {object}
   */


  _createClass(VirtualScroller, [{
    key: "getInitialState",
    value: function getInitialState(customState) {
      var items = this.initialItems;

      var state = _objectSpread({}, customState, this.getInitialLayoutState(items), {
        items: items,
        itemStates: new Array(items.length)
      });

      log('Initial state (autogenerated)', state);
      log('First shown item index', state.firstShownItemIndex);
      log('Last shown item index', state.lastShownItemIndex);
      return state;
    }
  }, {
    key: "getInitialLayoutValues",
    value: function getInitialLayoutValues(_ref5) {
      var itemsCount = _ref5.itemsCount,
          bypass = _ref5.bypass;
      return this.layout.getInitialLayoutValues({
        bypass: bypass,
        itemsCount: itemsCount,
        visibleAreaHeightIncludingMargins: this.scrollableContainer && 2 * this.getMargin() + this.scrollableContainer.getHeight()
      });
    }
  }, {
    key: "getInitialLayoutState",
    value: function getInitialLayoutState(items) {
      var itemsCount = items.length;

      var _this$getInitialLayou = this.getInitialLayoutValues({
        itemsCount: itemsCount,
        bypass: this.preserveScrollPositionOfTheBottomOfTheListOnMount
      }),
          firstShownItemIndex = _this$getInitialLayou.firstShownItemIndex,
          lastShownItemIndex = _this$getInitialLayou.lastShownItemIndex,
          beforeItemsHeight = _this$getInitialLayou.beforeItemsHeight,
          afterItemsHeight = _this$getInitialLayou.afterItemsHeight;

      var itemHeights = new Array(itemsCount); // Optionally preload items to be rendered.

      this.onBeforeShowItems(items, itemHeights, firstShownItemIndex, lastShownItemIndex); // This "initial" state object must include all possible state properties
      // because `this.setState()` gets called with this state on window resize,
      // when `VirtualScroller` gets reset.
      // Item states aren't included here because the state of all items should be
      // preserved on window resize.

      return {
        itemHeights: itemHeights,
        columnsCount: this._getColumnsCount ? this._getColumnsCount(this.scrollableContainer) : undefined,
        verticalSpacing: undefined,
        firstShownItemIndex: firstShownItemIndex,
        lastShownItemIndex: lastShownItemIndex,
        beforeItemsHeight: beforeItemsHeight,
        afterItemsHeight: afterItemsHeight
      };
    }
  }, {
    key: "getVerticalSpacing",
    value: function getVerticalSpacing() {
      return this.getState() && this.getState().verticalSpacing || 0;
    }
  }, {
    key: "getColumnsCount",
    value: function getColumnsCount() {
      return this.getState() && this.getState().columnsCount || 1;
    }
  }, {
    key: "getItemsCount",
    value: function getItemsCount() {
      return this.getState().items.length;
    }
  }, {
    key: "getMargin",
    value: function getMargin() {
      // `VirtualScroller` also items that are outside of the screen
      // by the amount of this "render ahead margin" (both on top and bottom).
      // The default "render ahead margin" is equal to the screen height:
      // this seems to be the optimal value for "Page Up" / "Page Down" navigation
      // and optimized mouse wheel scrolling (a user is unlikely to continuously
      // scroll past the height of a screen, and when they stop scrolling,
      // the list is re-rendered).
      var renderAheadMarginRatio = 1; // in scrollable container heights.

      return this.scrollableContainer.getHeight() * renderAheadMarginRatio;
    }
    /**
     * Calls `onItemFirstRender()` for items that haven't been
     * "seen" previously.
     * @param  {any[]} items
     * @param  {number[]} itemHeights
     * @param  {number} firstShownItemIndex
     * @param  {number} lastShownItemIndex
     */

  }, {
    key: "onBeforeShowItems",
    value: function onBeforeShowItems(items, itemHeights, firstShownItemIndex, lastShownItemIndex) {
      if (this.onItemInitialRender) {
        var i = firstShownItemIndex;

        while (i <= lastShownItemIndex) {
          if (itemHeights[i] === undefined) {
            this.onItemInitialRender(items[i]);
          }

          i++;
        }
      }
    }
  }, {
    key: "onMount",
    value: function onMount() {
      warn('`.onMount()` instance method name is deprecated, use `.listen()` instance method name instead.');
      this.listen();
    }
  }, {
    key: "render",
    value: function render() {
      warn('`.render()` instance method name is deprecated, use `.listen()` instance method name instead.');
      this.listen();
    }
    /**
     * Should be invoked after a "container" DOM Element is mounted (inserted into the DOM tree).
     */

  }, {
    key: "listen",
    value: function listen() {
      if (this.isRendered === false) {
        throw new Error('[virtual-scroller] Can\'t restart a `VirtualScroller` after it has been stopped');
      }

      log('~ Rendered (initial) ~'); // `this.isRendered = true` should be the first statement in this function,
      // otherwise `DOMVirtualScroller` would enter an infinite re-render loop.

      this.isRendered = true;
      this.onRenderedNewLayout();
      this.resize.listen();
      this.scroll.listen(); // Work around `<tbody/>` not being able to have `padding`.
      // https://gitlab.com/catamphetamine/virtual-scroller/-/issues/1

      if (this.tbody) {
        addTbodyStyles(this.getContainerElement());
      }

      if (this.preserveScrollPositionOfTheBottomOfTheListOnMount) ; else {
        this.onUpdateShownItemIndexes({
          reason: LAYOUT_REASON.MOUNT
        });
      }
    }
  }, {
    key: "onRenderedNewLayout",
    value: function onRenderedNewLayout() {
      // Update item vertical spacing.
      this.measureVerticalSpacing(); // Measure "newly shown" item heights.
      // Also re-validate already measured items' heights.

      this.itemHeights.measureItemHeights(this.getState().firstShownItemIndex, this.getState().lastShownItemIndex); // Update `<tbody/>` `padding`.
      // (`<tbody/>` is different in a way that it can't have `margin`, only `padding`).
      // https://gitlab.com/catamphetamine/virtual-scroller/-/issues/1

      if (this.tbody) {
        setTbodyPadding(this.getContainerElement(), this.getState().beforeItemsHeight, this.getState().afterItemsHeight);
      }
    }
  }, {
    key: "getVisibleAreaBoundsIncludingMargins",
    value: function getVisibleAreaBoundsIncludingMargins() {
      var visibleArea = this.scroll.getVisibleAreaBounds();
      visibleArea.top -= this.getMargin();
      visibleArea.bottom += this.getMargin();
      return visibleArea;
    }
    /**
     * Returns the list's top offset relative to the scrollable container's top edge.
     * @return {number}
     */

  }, {
    key: "onUnmount",
    value: function onUnmount() {
      warn('`.onUnmount()` instance method name is deprecated, use `.stop()` instance method name instead.');
      this.stop();
    }
  }, {
    key: "destroy",
    value: function destroy() {
      warn('`.destroy()` instance method name is deprecated, use `.stop()` instance method name instead.');
      this.stop();
    }
  }, {
    key: "stop",
    value: function stop() {
      this.isRendered = false;
      this.resize.stop();
      this.scroll.stop();
      this.waitForStylesToLoad.stop();

      if (this.layoutTimer) {
        clearTimeout(this.layoutTimer);
        this.layoutTimer = undefined;
      }
    }
    /**
     * Should be called right before `state` is updated.
     * @param  {object} prevState
     * @param  {object} newState
     */

  }, {
    key: "redoLayoutRightAfterRender",
    value: function redoLayoutRightAfterRender(_ref6) {
      var _this2 = this;

      var reason = _ref6.reason;

      // In React, `setTimeout()` is used to prevent a React error:
      // "Maximum update depth exceeded.
      //  This can happen when a component repeatedly calls
      //  `.setState()` inside `componentWillUpdate()` or `componentDidUpdate()`.
      //  React limits the number of nested updates to prevent infinite loops."
      if (this._useTimeoutInRenderLoop) {
        // Cancel a previously scheduled re-layout.
        if (this.layoutTimer) {
          clearTimeout(this.layoutTimer);
        } // Schedule a new re-layout.


        this.layoutTimer = setTimeout$1(function () {
          _this2.layoutTimer = undefined;

          _this2.onUpdateShownItemIndexes({
            reason: reason
          });
        }, 0);
      } else {
        this.onUpdateShownItemIndexes({
          reason: reason
        });
      }
    }
  }, {
    key: "measureVerticalSpacing",
    value: function measureVerticalSpacing() {
      if (this.getState().verticalSpacing === undefined) {
        log('~ Measure item vertical spacing ~');
        var verticalSpacing = getVerticalSpacing({
          container: this.getContainerElement(),
          screen: this.screen
        });

        if (verticalSpacing === undefined) {
          log('Not enough items rendered to measure vertical spacing');
        } else {
          log('Item vertical spacing', verticalSpacing);
          this.setState({
            verticalSpacing: verticalSpacing
          });
        }
      }
    }
  }, {
    key: "remeasureItemHeight",
    value: function remeasureItemHeight(i) {
      var _this$getState2 = this.getState(),
          firstShownItemIndex = _this$getState2.firstShownItemIndex;

      return this.itemHeights.remeasureItemHeight(i, firstShownItemIndex);
    }
  }, {
    key: "onItemStateChange",
    value: function onItemStateChange(i, itemState) {
      if (isDebug()) {
        log('~ Item state changed ~');
        log('Item', i);
        log('Previous state' + '\n' + JSON.stringify(this.getState().itemStates[i], null, 2));
        log('New state' + '\n' + JSON.stringify(itemState, null, 2));
      }

      this.getState().itemStates[i] = itemState;
    }
  }, {
    key: "onItemHeightChange",
    value: function onItemHeightChange(i) {
      log('~ Re-measure item height ~');
      log('Item', i);

      var _this$getState3 = this.getState(),
          itemHeights = _this$getState3.itemHeights;

      var previousHeight = itemHeights[i];

      if (previousHeight === undefined) {
        return reportError("\"onItemHeightChange()\" has been called for item ".concat(i, ", but that item hasn't been rendered before."));
      }

      var newHeight = this.remeasureItemHeight(i); // Check if the item is still rendered.

      if (newHeight === undefined) {
        // There could be valid cases when an item is no longer rendered
        // by the time `.onItemHeightChange(i)` gets called.
        // For example, suppose there's a list of several items on a page,
        // and those items are in "minimized" state (having height 100px).
        // Then, a user clicks an "Expand all items" button, and all items
        // in the list are expanded (expanded item height is gonna be 700px).
        // `VirtualScroller` demands that `.onItemHeightChange(i)` is called
        // in such cases, and the developer has properly added the code to do that.
        // So, if there were 10 "minimized" items visible on a page, then there
        // will be 10 individual `.onItemHeightChange(i)` calls. No issues so far.
        // But, as the first `.onItemHeightChange(i)` call executes, it immediately
        // ("synchronously") triggers a re-layout, and that re-layout finds out
        // that now, because the first item is big, it occupies most of the screen
        // space, and only the first 3 items are visible on screen instead of 10,
        // and so it leaves the first 3 items mounted and unmounts the rest 7.
        // Then, after `VirtualScroller` has rerendered, the code returns to
        // where it was executing, and calls `.onItemHeightChange(i)` for the
        // second item. It also triggers an immediate re-layout that finds out
        // that only the first 2 items are visible on screen, and it unmounts
        // the third one too. After that, it calls `.onItemHeightChange(i)`
        // for the third item, but that item is no longer rendered, so its height
        // can't be measured, and the same's for all the rest of the original 10 items.
        // So, even though the developer has written their code properly, there're
        // still situations when the item could be no longer rendered by the time
        // `.onItemHeightChange(i)` gets called.
        return warn('The item is no longer rendered. This is not necessarily a bug, and could happen, for example, when there\'re several `onItemHeightChange(i)` calls issued at the same time.');
      }

      log('Previous height', previousHeight);
      log('New height', newHeight);

      if (previousHeight !== newHeight) {
        log('~ Item height has changed ~'); // log('Item', i)

        this.onUpdateShownItemIndexes({
          reason: LAYOUT_REASON.ITEM_HEIGHT_CHANGED
        });
      }
    }
    /**
     * Validates the heights of items to be hidden on next render.
     * For example, a user could click a "Show more" button,
     * or an "Expand YouTube video" button, which would result
     * in the actual height of the list item being different
     * from what has been initially measured in `this.itemHeights[i]`,
     * if the developer didn't call `.onItemStateChange()` and `.onItemHeightChange(i)`.
     */

  }, {
    key: "validateWillBeHiddenItemHeightsAreAccurate",
    value: function validateWillBeHiddenItemHeightsAreAccurate(firstShownItemIndex, lastShownItemIndex) {
      var isValid = true;
      var i = this.getState().firstShownItemIndex;

      while (i <= this.getState().lastShownItemIndex) {
        if (i >= firstShownItemIndex && i <= lastShownItemIndex) ; else {
          // The item will be hidden. Re-measure its height.
          // The rationale is that there could be a situation when an item's
          // height has changed, and the developer has properly added an
          // `.onItemHeightChange(i)` call to notify `VirtualScroller`
          // about that change, but at the same time that wouldn't work.
          // For example, suppose there's a list of several items on a page,
          // and those items are in "minimized" state (having height 100px).
          // Then, a user clicks an "Expand all items" button, and all items
          // in the list are expanded (expanded item height is gonna be 700px).
          // `VirtualScroller` demands that `.onItemHeightChange(i)` is called
          // in such cases, and the developer has properly added the code to do that.
          // So, if there were 10 "minimized" items visible on a page, then there
          // will be 10 individual `.onItemHeightChange(i)` calls. No issues so far.
          // But, as the first `.onItemHeightChange(i)` call executes, it immediately
          // ("synchronously") triggers a re-layout, and that re-layout finds out
          // that now, because the first item is big, it occupies most of the screen
          // space, and only the first 3 items are visible on screen instead of 10,
          // and so it leaves the first 3 items mounted and unmounts the rest 7.
          // Then, after `VirtualScroller` has rerendered, the code returns to
          // where it was executing, and calls `.onItemHeightChange(i)` for the
          // second item. It also triggers an immediate re-layout that finds out
          // that only the first 2 items are visible on screen, and it unmounts
          // the third one too. After that, it calls `.onItemHeightChange(i)`
          // for the third item, but that item is no longer rendered, so its height
          // can't be measured, and the same's for all the rest of the original 10 items.
          // So, even though the developer has written their code properly, the
          // `VirtualScroller` still ends up having incorrect `itemHeights[]`:
          // `[700px, 700px, 100px, 100px, 100px, 100px, 100px, 100px, 100px, 100px]`
          // while it should have been `700px` for all of them.
          // To work around such issues, every item's height is re-measured before it
          // gets hidden.
          var previouslyMeasuredItemHeight = this.getState().itemHeights[i];
          var actualItemHeight = this.remeasureItemHeight(i);

          if (actualItemHeight !== previouslyMeasuredItemHeight) {
            isValid = false;
            warn('Item', i, 'will be unmounted at next render because it\'s no longer visible. Its height has changed from', previouslyMeasuredItemHeight, 'to', actualItemHeight, 'since it was last measured. This is not necessarily a bug, and could happen, for example, when there\'re several `onItemHeightChange(i)` calls issued at the same time, and the first one triggers a re-layout before the rest of them have had a chance to be executed.');
          }
        }

        i++;
      }

      return isValid;
    }
    /**
     * Updates the "from" and "to" shown item indexes.
     * If the list is visible and some of the items being shown are new
     * and are required to be measured first, then
     * `redoLayoutAfterMeasuringItemHeights` is `true`.
     * If the list is visible and all items being shown have been encountered
     * (and measured) before, then `redoLayoutAfterMeasuringItemHeights` is `false`.
     */

  }, {
    key: "updateItems",

    /**
     * @deprecated
     * `.updateItems()` has been renamed to `.setItems()`.
     */
    value: function updateItems(newItems, options) {
      return this.setItems(newItems, options);
    }
    /**
     * Updates `items`. For example, can prepend or append new items to the list.
     * @param  {any[]} newItems
     * @param {boolean} [options.preserveScrollPositionOnPrependItems] — Set to `true` to enable "restore scroll position after prepending items" feature (could be useful when implementing "Show previous items" button).
     */

  }, {
    key: "setItems",
    value: function setItems(newItems) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      // * @param  {object} [newCustomState] — If `customState` was passed to `getInitialState()`, this `newCustomState` updates it.
      var _this$getState4 = this.getState(),
          previousItems = _this$getState4.items;

      var _this$getState5 = this.getState(),
          itemStates = _this$getState5.itemStates,
          itemHeights = _this$getState5.itemHeights;

      log('~ Update items ~');
      var layout;
      var itemsDiff = this.getItemsDiff(previousItems, newItems); // If it's an "incremental" update.

      if (itemsDiff && !this.layoutResetPending) {
        var _this$getState6 = this.getState(),
            firstShownItemIndex = _this$getState6.firstShownItemIndex,
            lastShownItemIndex = _this$getState6.lastShownItemIndex,
            beforeItemsHeight = _this$getState6.beforeItemsHeight,
            afterItemsHeight = _this$getState6.afterItemsHeight;

        layout = {
          firstShownItemIndex: firstShownItemIndex,
          lastShownItemIndex: lastShownItemIndex,
          beforeItemsHeight: beforeItemsHeight,
          afterItemsHeight: afterItemsHeight
        };
        var prependedItemsCount = itemsDiff.prependedItemsCount,
            appendedItemsCount = itemsDiff.appendedItemsCount;

        if (prependedItemsCount > 0) {
          log('Prepend', prependedItemsCount, 'items');
          itemHeights = new Array(prependedItemsCount).concat(itemHeights);

          if (itemStates) {
            itemStates = new Array(prependedItemsCount).concat(itemStates);
          }
        }

        if (appendedItemsCount > 0) {
          log('Append', appendedItemsCount, 'items');
          itemHeights = itemHeights.concat(new Array(appendedItemsCount));

          if (itemStates) {
            itemStates = itemStates.concat(new Array(appendedItemsCount));
          }
        }

        this.layout.updateLayoutForItemsDiff(layout, itemsDiff, {
          itemsCount: newItems.length
        });

        if (prependedItemsCount > 0) {
          // `preserveScrollPosition` option name is deprecated,
          // use `preserveScrollPositionOnPrependItems` instead.
          if (options.preserveScrollPositionOnPrependItems || options.preserveScrollPosition) {
            if (this.getState().firstShownItemIndex === 0) {
              this.restoreScroll.captureScroll({
                previousItems: previousItems,
                newItems: newItems,
                prependedItemsCount: prependedItemsCount
              });
              this.layout.showItemsFromTheStart(layout);
            }
          }
        }
      } else {
        log('Items have changed, and', itemsDiff ? 'a re-layout from scratch has been requested.' : 'it\'s not a simple append and/or prepend.', 'Rerender the entire list from scratch.');
        log('Previous items', previousItems);
        log('New items', newItems);
        itemHeights = new Array(newItems.length);
        itemStates = new Array(newItems.length);
        layout = this.getInitialLayoutValues({
          itemsCount: newItems.length
        });
      }

      log('~ Update state ~');
      log('First shown item index', layout.firstShownItemIndex);
      log('Last shown item index', layout.lastShownItemIndex);
      log('Before items height', layout.beforeItemsHeight);
      log('After items height (actual or estimated)', layout.afterItemsHeight); // Optionally preload items to be rendered.

      this.onBeforeShowItems(newItems, itemHeights, layout.firstShownItemIndex, layout.lastShownItemIndex); // `this.newItemsPending` will be cleared in `didUpdateState()`.

      this.newItemsPending = newItems; // Update state.

      this.setState(_objectSpread({}, layout, {
        items: newItems,
        itemStates: itemStates,
        itemHeights: itemHeights
      }));
    }
  }, {
    key: "getItemsDiff",
    value: function getItemsDiff$1(previousItems, newItems) {
      return getItemsDiff(previousItems, newItems, this.isItemEqual);
    }
  }]);

  return VirtualScroller;
}();

const virtualScrollerComponentCss = "ionx-virtual-scroller{display:block}";

let VirtualScrollerComponent = class extends HTMLElement {
  constructor() {
    super();
    this.__registerHost();
    this.preserveScrollPositionOnPrependItems = true;
  }
  itemsChanged(newItems) {
    const { preserveScrollPositionOnPrependItems } = this;
    this.scroller.setItems(newItems, { preserveScrollPositionOnPrependItems });
  }
  connectedCallback() {
    const container = this.element;
    this.state = {};
    this.scroller = new VirtualScroller(() => container, this.items, {
      tbody: false,
      scrollableContainer: this.element.closest("ion-content").shadowRoot.querySelector(".inner-scroll"),
      getItemId: this.itemKey ? (item) => this.itemKey(item) : undefined,
      getState: () => this.state,
      setState: (state, callbacks) => {
        this.prevState = this.state;
        const newState = { ...this.prevState, ...state };
        if (!shallowEqual$1(this.prevState, newState)) {
          callbacks.willUpdateState(newState, this.prevState);
          this.didUpdateState = callbacks.didUpdateState;
          this.state = newState;
          forceUpdate(this);
        }
      }
    });
  }
  componentDidLoad() {
    setTimeout(() => this.scroller.listen());
  }
  componentDidRender() {
    if (this.didUpdateState) {
      const update = this.didUpdateState;
      const state = this.prevState;
      setTimeout(() => update(state));
      this.didUpdateState = undefined;
    }
  }
  disconnectedCallback() {
    this.scroller.stop();
  }
  render() {
    const { items, firstShownItemIndex, lastShownItemIndex, beforeItemsHeight, afterItemsHeight, itemHeights } = this.state;
    if (itemHeights.find(h => typeof h === "number") || items.length === 0) {
      this.beforeItemsHeight = beforeItemsHeight;
      this.afterItemsHeight = afterItemsHeight;
    }
    const itemsToRender = [];
    for (let i = firstShownItemIndex; i <= lastShownItemIndex; i++) {
      itemsToRender.push([items[i], i]);
    }
    return h(Host, { style: { display: "block", paddingTop: `${this.beforeItemsHeight}px`, paddingBottom: `${this.afterItemsHeight}px` } }, itemsToRender.map(item => this.renderItem(item[0], item[1])));
  }
  get element() { return this; }
  static get watchers() { return {
    "items": ["itemsChanged"]
  }; }
  static get style() { return virtualScrollerComponentCss; }
};
VirtualScrollerComponent = /*@__PURE__*/ proxyCustomElement(VirtualScrollerComponent, [0, "ionx-virtual-scroller", {
    "items": [16],
    "renderItem": [16],
    "itemKey": [16],
    "preserveScrollPositionOnPrependItems": [4, "preserve-scroll-position-on-prepend-items"],
    "estimatedItemHeight": [2, "estimated-item-height"]
  }]);
function defineCustomElement$1() {
  if (typeof customElements === "undefined") {
    return;
  }
  const components = ["ionx-virtual-scroller"];
  components.forEach(tagName => { switch (tagName) {
    case "ionx-virtual-scroller":
      if (!customElements.get(tagName)) {
        customElements.define(tagName, VirtualScrollerComponent);
      }
      break;
  } });
}
defineCustomElement$1();

const IonxVirtualScroller = VirtualScrollerComponent;
const defineCustomElement = defineCustomElement$1;

export { IonxVirtualScroller, defineCustomElement };
